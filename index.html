<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg width='48' height='48' viewBox='0 0 48 48' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='48' height='48' rx='8' fill='black'/%3E%3Cg clip-path='url(%23clip0_577_4374)'%3E%3Cpath d='M17.9401 21.3655C20.0097 21.3655 21.6874 19.6806 21.6874 17.6021C21.6874 15.5236 20.0097 13.8386 17.9401 13.8386C15.8705 13.8386 14.1927 15.5236 14.1927 17.6021C14.1927 19.6806 15.8705 21.3655 17.9401 21.3655Z' fill='white'/%3E%3Cpath d='M24.0963 16.5269C26.1659 16.5269 27.8436 14.8419 27.8436 12.7634C27.8436 10.6849 26.1659 9 24.0963 9C22.0267 9 20.349 10.6849 20.349 12.7634C20.349 14.8419 22.0267 16.5269 24.0963 16.5269Z' fill='white'/%3E%3Cpath d='M30.2527 21.3655C32.3223 21.3655 34 19.6806 34 17.6021C34 15.5236 32.3223 13.8386 30.2527 13.8386C28.1831 13.8386 26.5054 15.5236 26.5054 17.6021C26.5054 19.6806 28.1831 21.3655 30.2527 21.3655Z' fill='white'/%3E%3Cpath d='M23.8394 28.7849C23.0899 27.1397 20.1831 21.8386 14 22.3602V32.4462C14 32.4462 22.1531 32.4462 22.9882 38.9999H24.6852C25.5203 32.4408 33.6734 32.4462 33.6734 32.4462V22.3602C27.4904 21.8386 24.5835 27.1397 23.834 28.7849H23.8394Z' fill='white'/%3E%3C/g%3E%3Cdefs%3E%3CclipPath id='clip0_577_4374'%3E%3Crect width='20' height='30' fill='white' transform='translate(14 9)'/%3E%3C/clipPath%3E%3C/defs%3E%3C/svg%3E">
    <title>IDNote</title>

    <!-- DaisyUI + Tailwind CSS -->
    <link href="https://cdn.jsdelivr.net/npm/daisyui@5" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="https://unpkg.com/vditor@3.10.4/dist/index.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/3.0.1/modern-normalize.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

    <!-- Vue 3 ÂíåÁõ∏ÂÖ≥Â∫ì -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/vue-demi@0.14.10/lib/index.iife.js"></script>
    <script src="https://unpkg.com/pinia@2.1.7/dist/pinia.iife.js"></script>
    <script src="https://unpkg.com/@vueuse/shared@10.7.2/index.iife.min.js"></script>
    <script src="https://unpkg.com/@vueuse/core@10.7.2/index.iife.min.js"></script>

    <!-- Â∑•ÂÖ∑Â∫ì -->
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dexie@3.2.4/dist/dexie.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/metaidjs-v2@1.0.0/dist/metaid.umd.js"></script>
    <script src="https://unpkg.com/vditor@3.10.4/dist/index.min.js"></script>
    <script src="https://unpkg.com/marked@12.0.0/marked.min.js"></script>
    <!-- Buffer ÊµèËßàÂô®ÁâàÊú¨ -->
    <script src="https://cdn.jsdelivr.net/npm/buffer@6.0.3/dist/buffer.min.js"></script>
    <script>
        // Á°Æ‰øù Buffer ÂÖ®Â±ÄÂèØÁî®
        if (typeof buffer !== 'undefined' && buffer.Buffer) {
            window.Buffer = buffer.Buffer;
        }
    </script>

    <style>
        /* Ëá™ÂÆö‰πâÊ†∑Âºè */
        .modal-backdrop {
            background: rgba(0, 0, 0, 0.5);
        }

        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.3s;
        }

        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }

        .scale-enter-active, .scale-leave-active {
            transition: all 0.3s;
        }

        .scale-enter-from, .scale-leave-to {
            opacity: 0;
            transform: scale(0.95);
        }

        /* Loading spinner */
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Áî®Êà∑Â§¥ÂÉèÊ†∑Âºè */
        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 100%;
            object-fit: cover;
        }

        /* ÂàÜÈ°µÂô®Ê†∑Âºè */
        .pagination-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        /* ÂìçÂ∫îÂºèÂàÜÈ°µ */
        @media (max-width: 640px) {
            .pagination-container {
                gap: 0.25rem;
            }
            .pagination-container .btn-sm {
                min-height: 2rem;
                height: 2rem;
                padding-left: 0.5rem;
                padding-right: 0.5rem;
                font-size: 0.75rem;
            }
        }

        /* Ëá™ÂÆö‰πâ container ÊúÄÂ§ßÂÆΩÂ∫¶ */
        .container {
            max-width: 1280px !important;
        }

        /* Ëá™ÂÆö‰πâ card ÊúÄÂ§ßÂÆΩÂ∫¶ */
        .card {
            max-width: 640px !important;
        }

        /* Vditor ÁºñËæëÂô®Ê†∑Âºè */
        #vditor {
            border: 1px solid #e5e7eb;
        }

        /* Vditor ÂÖ®Â±èÊ®°Âºè z-index ÊéßÂà∂ */
        .vditor--fullscreen {
            z-index: 999 !important;
        }

        /* Vditor Â∑•ÂÖ∑Ê†èÊ†∑Âºè */
        .vditor-toolbar {
            background-color: #f9fafb;
        }

        /* form-control ‰∏≠ label Âíå input Èó¥Ë∑ù‰ºòÂåñ */
        .form-control .label {
            margin-bottom: 0.5rem;
        }

        .form-control .label + input,
        .form-control .label + textarea,
        .form-control .label + select,
        .form-control .label + div {
            margin-top: 0.5rem;
        }

        /* ÈôÑ‰ª∂È¢ÑËßàÊ†∑Âºè */
        .attachment-preview {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: #f9f9f9;
            border: 1px solid #e5e5e5;
            border-radius: 0.375rem;
        }

        .attachment-preview .preview-header {
            margin-bottom: 1rem;
        }

        .attachment-preview .preview-label {
            font-size: 0.95rem;
            color: #666;
            font-weight: 500;
        }

        .attachment-preview .preview-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 1.875rem;
        }

        .attachment-preview .preview-item {
            width: 150px;
            height: 150px;
            position: relative;
            display: flex;
            flex-direction: column;
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 0.375rem;
            overflow: hidden;
            transition: all 0.2s;
        }

        .attachment-preview .preview-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-color: #149dd3;
        }

        .attachment-preview .preview-item:hover .delete-btn {
            opacity: 1;
        }

        .attachment-preview .preview-content {
            width: 100px;
            height: 100px;
            overflow: hidden;
            background: #f5f5f5;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .attachment-preview .preview-image {
            cursor: pointer;
        }

        .attachment-preview .preview-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.2s;
        }

        .attachment-preview .preview-image img:hover {
            transform: scale(1.05);
        }

        .attachment-preview .preview-video {
            background: #000;
            padding: 0;
        }

        .attachment-preview .preview-video video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .attachment-preview .preview-audio {
            flex-direction: column;
            gap: 0.5rem;
            padding: 1rem;
        }

        .attachment-preview .preview-audio .audio-icon {
            color: #149dd3;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .attachment-preview .preview-audio .audio-player {
            width: 100%;
            max-width: 180px;
        }

        .attachment-preview .preview-document {
            cursor: pointer;
            flex-direction: column;
            gap: 0.5rem;
            color: #666;
            transition: color 0.2s;
        }

        .attachment-preview .preview-document:hover {
            color: #149dd3;
        }

        .attachment-preview .preview-document svg {
            flex-shrink: 0;
        }

        .attachment-preview .preview-document .file-type-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: inherit;
            text-transform: uppercase;
        }

        .attachment-preview .preview-info {
            display: flex;
            flex-direction: column;
            padding: 0.75rem;
            gap: 0.25rem;
        }

        .attachment-preview .preview-info .file-name {
            font-size: 0.875rem;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .attachment-preview .preview-info .file-size {
            font-size: 0.75rem;
            color: #999;
        }

        .attachment-preview .delete-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            padding: 0.5rem;
            background: rgba(220, 53, 69, 0.9);
            color: #fff;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .attachment-preview .delete-btn:hover {
            background: rgba(200, 35, 51, 0.95);
        }

        .attachment-preview .delete-btn svg {
            width: 16px;
            height: 16px;
        }

        /* ÁßªÂä®Á´ØÈÄÇÈÖç */
        @media (max-width: 768px) {
            .attachment-preview .preview-list {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 0.75rem;
            }

            .attachment-preview .delete-btn {
                opacity: 1;
            }
        }

        /* Prose Ê†∑Âºè - Áî®‰∫é Markdown Ê∏≤Êüì */
        .prose {
            color: #374151;
            max-width: 65ch;
            line-height: 1.75;
        }

        .prose p {
            margin-top: 1.25em;
            margin-bottom: 1.25em;
        }

        .prose h1 {
            color: #111827;
            font-weight: 800;
            font-size: 2.25em;
            margin-top: 0;
            margin-bottom: 0.8888889em;
            line-height: 1.1111111;
        }

        .prose h2 {
            color: #111827;
            font-weight: 700;
            font-size: 1.5em;
            margin-top: 2em;
            margin-bottom: 1em;
            line-height: 1.3333333;
        }

        .prose h3 {
            color: #111827;
            font-weight: 600;
            font-size: 1.25em;
            margin-top: 1.6em;
            margin-bottom: 0.6em;
            line-height: 1.6;
        }

        .prose h4 {
            color: #111827;
            font-weight: 600;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            line-height: 1.5;
        }

        .prose strong {
            color: #111827;
            font-weight: 600;
        }

        .prose em {
            font-style: italic;
        }

        .prose code {
            color: #111827;
            font-weight: 600;
            font-size: 0.875em;
            background-color: #f3f4f6;
            padding: 0.2em 0.4em;
            border-radius: 0.25rem;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        }

        .prose pre {
            color: #e5e7eb;
            background-color: #1f2937;
            overflow-x: auto;
            font-size: 0.875em;
            line-height: 1.7142857;
            margin-top: 1.7142857em;
            margin-bottom: 1.7142857em;
            border-radius: 0.375rem;
            padding: 0.8571429em 1.1428571em;
        }

        .prose pre code {
            background-color: transparent;
            border-width: 0;
            border-radius: 0;
            padding: 0;
            font-weight: 400;
            color: inherit;
            font-size: inherit;
            font-family: inherit;
            line-height: inherit;
        }

        .prose a {
            color: #3b82f6;
            text-decoration: underline;
            font-weight: 500;
        }

        .prose a:hover {
            color: #2563eb;
        }

        .prose ul {
            list-style-type: disc;
            margin-top: 1.25em;
            margin-bottom: 1.25em;
            padding-left: 1.625em;
        }

        .prose ol {
            list-style-type: decimal;
            margin-top: 1.25em;
            margin-bottom: 1.25em;
            padding-left: 1.625em;
        }

        .prose li {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

        .prose blockquote {
            font-weight: 500;
            font-style: italic;
            color: #111827;
            border-left-width: 0.25rem;
            border-left-color: #e5e7eb;
            quotes: "\201C""\201D""\2018""\2019";
            margin-top: 1.6em;
            margin-bottom: 1.6em;
            padding-left: 1em;
        }

        .prose img {
            margin-top: 2em;
            margin-bottom: 2em;
            max-width: 100%;
            border-radius: 0.5rem;
        }

        .prose table {
            width: 100%;
            table-layout: auto;
            text-align: left;
            margin-top: 2em;
            margin-bottom: 2em;
            font-size: 0.875em;
            line-height: 1.7142857;
        }

        .prose thead {
            border-bottom-width: 1px;
            border-bottom-color: #d1d5db;
        }

        .prose thead th {
            color: #111827;
            font-weight: 600;
            vertical-align: bottom;
            padding-right: 0.5714286em;
            padding-bottom: 0.5714286em;
            padding-left: 0.5714286em;
        }

        .prose tbody tr {
            border-bottom-width: 1px;
            border-bottom-color: #e5e7eb;
        }

        .prose tbody td {
            vertical-align: baseline;
            padding: 0.5714286em;
        }

        .prose hr {
            border-color: #e5e7eb;
            border-top-width: 1px;
            margin-top: 3em;
            margin-bottom: 3em;
        }

        .prose.max-w-none {
            max-width: none;
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <script type="module">
        // Á≠âÂæÖÊâÄÊúâÂ∫ìÂä†ËΩΩÂÆåÊàê
        window.addEventListener('load', () => {
            console.log('All libraries loaded, checking...');
            console.log('Vue:', typeof Vue !== 'undefined' ? '‚úì' : '‚úó');
            console.log('Pinia:', typeof Pinia !== 'undefined' ? '‚úì' : '‚úó');
            console.log('VueUse:', typeof VueUse !== 'undefined' ? '‚úì' : '‚úó');
            console.log('Buffer:', typeof Buffer !== 'undefined' ? '‚úì' : '‚úó');
            console.log('MetaIDJs:', typeof MetaIDJs !== 'undefined' ? '‚úì' : '‚úó');
            console.log('Vditor:', typeof Vditor !== 'undefined' ? '‚úì' : '‚úó');
            console.log('marked:', typeof marked !== 'undefined' ? '‚úì' : '‚úó');
            if (typeof marked !== 'undefined') {
                console.log('marked.parse:', typeof marked.parse === 'function' ? '‚úì' : '‚úó');
                console.log('marked version info:', marked);
            }
            // MetaIDJs Áé∞Âú®ÂèØ‰ª•‰Ωú‰∏∫ÂÖ®Â±ÄÂØπË±°‰ΩøÁî®

        });

        // Ê£ÄÊü•ÂøÖË¶ÅÁöÑÂÖ®Â±ÄÂèòÈáè
        if (typeof Vue === 'undefined') {
            throw new Error('Vue is not loaded');
        }
        if (typeof Pinia === 'undefined') {
            throw new Error('Pinia is not loaded');
        }
        if (typeof VueUse === 'undefined') {
            console.warn('VueUse is not loaded - will use fallback implementation');
        }
        if (typeof Buffer === 'undefined') {
            console.warn('Buffer is not loaded - Buffer operations will be limited');
            // Êèê‰æõÁÆÄÂçïÁöÑ Buffer ÈôçÁ∫ßÂÆûÁé∞
            window.Buffer = {
                from: (data, encoding) => {
                    if (encoding === 'hex') {
                        // Â∞Ü hex Â≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫Â≠óËäÇÊï∞ÁªÑ
                        const bytes = [];
                        for (let i = 0; i < data.length; i += 2) {
                            bytes.push(parseInt(data.substr(i, 2), 16));
                        }
                        return {
                            toString: (toEncoding) => {
                                if (toEncoding === 'base64') {
                                    // ÁÆÄÂçïÁöÑ base64 ÁºñÁ†Å
                                    return btoa(String.fromCharCode.apply(null, bytes));
                                }
                                return data;
                            }
                        };
                    }
                    return { toString: () => data };
                }
            };
        }

        const { createApp, ref, reactive, computed, onMounted, onUnmounted,onBeforeUnmount, watch, nextTick } = Vue;
        const { defineStore, createPinia } = Pinia;

        // ==================== Meta-Contract Ëß£ÊûÑ ====================
        // ‰ªéÂÖ®Â±Ä MetaIDJs ÂØπË±°‰∏≠Ëé∑Âèñ TxComposer Âíå mvc
        let TxComposer, mvc;

        // Á≠âÂæÖ MetaIDJs Âä†ËΩΩÂÆåÊàê
        function waitForMetaIDJs() {
            return new Promise((resolve) => {
                if (typeof MetaIDJs !== 'undefined') {
                    TxComposer = MetaIDJs.TxComposer;
                    mvc = MetaIDJs.mvc;
                    resolve();
                } else {
                    const checkInterval = setInterval(() => {
                        if (typeof MetaIDJs !== 'undefined') {
                            TxComposer = MetaIDJs.TxComposer;
                            mvc = MetaIDJs.mvc;
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 100);
                }
            });
        }

        // VueUse Core - ‰ΩøÁî®Ê≠£Á°ÆÁöÑÂÖ®Â±ÄÂèòÈáèÂêçÔºåÂ¶ÇÊûúÂ§±Ë¥•Âàô‰ΩøÁî®ÈôçÁ∫ßÂÆûÁé∞
        let useLocalStorage, createGlobalState;

        if (typeof VueUse !== 'undefined') {
            ({ useLocalStorage, createGlobalState } = VueUse);
        } else {
            // ÈôçÁ∫ßÂÆûÁé∞ÔºöËá™Â∑±ÂÆûÁé∞ useLocalStorage Âíå createGlobalState
            console.warn('VueUse not found, using fallback implementation');

            useLocalStorage = (key, initialValue) => {
                const data = ref(initialValue);

                // ‰ªé localStorage ËØªÂèñÂàùÂßãÂÄº
                try {
                    const item = localStorage.getItem(key);
                    if (item !== null) {
                        data.value = JSON.parse(item);
                    }
                } catch (error) {
                    console.error('Error reading from localStorage:', error);
                }

                // ÁõëÂê¨ÂèòÂåñÂπ∂‰øùÂ≠òÂà∞ localStorage
                watch(data, (newValue) => {
                    try {
                        localStorage.setItem(key, JSON.stringify(newValue));
                    } catch (error) {
                        console.error('Error writing to localStorage:', error);
                    }
                }, { deep: true });

                return data;
            };

            createGlobalState = (stateFactory) => {
                let state;
                return () => {
                    if (!state) {
                        state = stateFactory();
                    }
                    return state;
                };
            };
        }

        // ==================== Â∏∏ÈáèÂÆö‰πâ ====================
        const CONSTANTS = {
            NETWORK: 'livenet',
            SIGNING_MESSAGE: 'IDNote Authentication',
            MAN_PUB_KEY: '048add0a6298f10a97785f7dd069eedb83d279a6f03e73deec0549e7d6fcaac4eef2c279cf7608be907a73c89eb44c28db084c27b588f1bd869321a6f104ec642d',
            MAN_BASE_URL: 'https://man.metaid.io/api',
            MAN_V2_BASE_URL:'https://manapi.metaid.io',
            BTC_FEE_RATE_URL: 'https://api.mvcscan.com/browser/v1/fees/recommended?chain=btc',
            MVC_FEE_RATE_URL: 'https://api.mvcscan.com/browser/v1/fees/recommended?net=livenet',
        };

        // ==================== Toast/Alert Â∑•ÂÖ∑ ====================
        // ÂàõÂª∫‰∏Ä‰∏™ÁÆÄÂçïÁöÑtoastÁ≥ªÁªü‰ΩøÁî®DaisyUIÁöÑalert
        const useToast = createGlobalState(() => {
            const alerts = ref([]);
            let alertId = 0;

            const showToast = (message, type = 'info') => {
                const id = alertId++;
                alerts.value.push({ id, message, type });
                setTimeout(() => {
                    alerts.value = alerts.value.filter(a => a.id !== id);
                }, 3000);
            };

            return { alerts, showToast };
        });

        // ==================== Â∑•ÂÖ∑ÂáΩÊï∞ ====================
        // Âª∂ËøüÂáΩÊï∞
        function sleep(timer = 2000) {
            return new Promise(resolve => setTimeout(resolve, timer));
        }

        // ÂÆåÊï¥ÈáçÊñ∞Âä†ËΩΩÈ°µÈù¢
        function completeReload() {
            const url = new URL(window.location.href);
            url.searchParams.delete('clear');
            url.searchParams.delete('address');
            window.location.href = url.href;
        }

        // ==================== HTTP ËØ∑Ê±ÇÂ∑•ÂÖ∑ (‰ΩøÁî® Fetch ÊõøÊç¢ Axios) ====================
        // ÂàõÂª∫HTTPËØ∑Ê±ÇÁ±ª
        class HttpRequest {
            constructor(baseURL, config = {}) {
                this.baseURL = baseURL;
                this.config = config;
            }

            getToken() {
                return localStorage.getItem('metaid_access_token');
            }

            async request(url, options = {}) {
                //const token = this.getToken();
                const headers = {
                    'Content-Type': 'application/json',
                    ...options.headers,
                };

                // if (token) {
                //     headers.Authorization = `Bearer ${token}`;
                // }

                try {
                    console.log(`üì§ [${options.method || 'GET'}] ${url}`);

                    const response = await fetch(this.baseURL + url, {
                        ...options,
                        headers,
                    });

                    console.log(`üì• [${options.method || 'GET'}] ${url} - Status: ${response.status}`);

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();

                    // Ëá™ÂÆö‰πâÂìçÂ∫îÂ§ÑÁêÜ
                    if (this.config.responseHandler) {
                        return this.config.responseHandler({ data });
                    }

                    // ÈªòËÆ§ÂìçÂ∫îÂ§ÑÁêÜ
                    if (data && typeof data.code === 'number') {
                        if (data.code === 1 || data.code === 0 || data.code === 200) {
                            return data.data !== undefined ? data.data : data;
                        }
                        throw new Error(data.message || 'ËØ∑Ê±ÇÂ§±Ë¥•');
                    }

                    return data;
                } catch (error) {
                    console.error('‚ùå Request error:', error);
                    throw error;
                }
            }

            async get(url, params = {}) {
                const query = new URLSearchParams(params).toString();
                const fullUrl = query ? `${url}?${query}` : url;
                return this.request(fullUrl, { method: 'GET' });
            }

            async post(url, data = {}) {
                return this.request(url, {
                    method: 'POST',
                    body: JSON.stringify(data),
                });
            }
        }

        // MAN API ÂÆû‰æã
        const manApi = new HttpRequest(CONSTANTS.MAN_BASE_URL, {
            responseHandler: ({ data }) => {
                return new Promise((resolve, reject) => {
                    if (data && typeof data.code === 'number') {
                        if (data.code === 1) {
                            resolve(data.data);
                        } else {
                            reject({ code: data.code, message: data.message || 'ËØ∑Ê±ÇÂ§±Ë¥•' });
                        }
                    } else {
                        resolve(data.data || data);
                    }
                });
            },
        });

        // ==================== Meta-Contract Áõ∏ÂÖ≥ÂáΩÊï∞ ====================

        // ËæÖÂä©ÂáΩÊï∞ÔºöÁîüÊàêÂîØ‰∏ÄÈîÆ
        function generateKey() {
            return (
                'key_' +
                Date.now() +
                '_' +
                Math.random()
                    .toString(36)
                    .slice(2, 8)
            );
        }

        // Ëé∑ÂèñÂ≠óÁ¨¶‰∏≤ UTF-8 Â≠óËäÇÂ§ßÂ∞è
        function getStringSize(str) {
            return new TextEncoder().encode(str).length;
        }

        // Âà§Êñ≠ÊòØÂê¶Ë∂ÖËøá 1MB
        function isBiggerThan1MB(str) {
            return getStringSize(str) > 1024 * 1024;
        }

        // ÊûÑÂª∫ MetaID OpReturn V2 Êï∞ÊçÆ
        function buildOpReturnV2(metaidData, options) {
            const res1 = ['metaid', metaidData.operation];
            const res2 = [];

            if (metaidData.operation !== 'init') {
                res2.push(metaidData.path);
                res2.push(metaidData?.encryption ?? '0');
                res2.push(metaidData?.version ?? '1.0.0');
                res2.push(metaidData?.contentType ?? 'text/plain;utf-8');

                const body = metaidData.body == null
                    ? undefined
                    : Buffer.isBuffer(metaidData.body)
                    ? metaidData.body
                    : Buffer.from(metaidData.body, metaidData?.encoding ?? 'utf-8');
                res2.push(body);
            }

            return [...res1, ...res2];
        }

        // ÂπøÊí≠‰∫§ÊòìÂà∞ API
        async function broadcastToApi({ txHex, network, chain = 'mvc' }) {
            try {
                const response = await fetch('https://www.metalet.space/wallet-api/v3/tx/broadcast', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        chain: chain,
                        net: network,
                        rawTx: txHex,
                    }),
                });

                const result = await response.json();
                const { data: txid, message } = result;

                if (!txid) {
                    throw new Error(message);
                }

                return { txid };
            } catch (error) {
                console.error('Broadcast error:', error);
                throw error;
            }
        }

        // Âçï‰∏™‰∫§ÊòìÂπøÊí≠
        async function broadcast({ txComposer, network }) {
            const txHex = txComposer.getTx().toString();
            const { txid } = await broadcastToApi({ txHex, network });
            console.log('txid', txid);
            return { txid };
        }

        // ÊâπÈáèÂπøÊí≠‰∫§Êòì
        async function batchBroadcast({ txComposer, network }) {
            const res = [];
            for (let i = 0; i < txComposer.length; i++) {
                const broadcastRes = await broadcast({
                    txComposer: txComposer[i],
                    network,
                });
                res.push(broadcastRes);
            }
            return res;
        }

        // ÊîØ‰ªòÂáΩÊï∞
        async function pay({ transactions, feeb }) {
            const params = {
                transactions: transactions.map(transaction => {
                    return {
                        txComposer: transaction.txComposer.serialize(),
                        message: transaction.message,
                    };
                }),
                hasMetaid: true,
                feeb,
            };

            // Â§ÑÁêÜÂ§ßÊï∞ÊçÆÂàÜÁâáÂ≠òÂÇ®
            if (window.metaidwallet.storageChunk && isBiggerThan1MB(JSON.stringify(params))) {
                const key = generateKey();
                const data = JSON.stringify(params);
                const chunkSize = 256 * 1024; // ÊØèÁâá 256KB
                const total = Math.ceil(data.length / chunkSize);

                for (let i = 0; i < total; i++) {
                    const chunk = data.slice(i * chunkSize, (i + 1) * chunkSize);
                    await window.metaidwallet.storageChunk({ chunk, index: i, total, key });
                }

                const ret = await window.metaidwallet.pay({
                    useChunk: true,
                    chunkKey: key,
                });

                const { payedTransactions, status, message } = ret;

                if (status) {
                    throw new Error(message || status);
                }

                return payedTransactions.map((txComposerSerialized) => {
                    return TxComposer.deserialize(txComposerSerialized);
                });
            }

            // Ê≠£Â∏∏ÊîØ‰ªòÊµÅÁ®ã
            const ret = await window.metaidwallet.pay(params);
            const { payedTransactions, status, message } = ret;

            if (status) {
                throw new Error(message || status);
            }

            return payedTransactions.map((txComposerSerialized) => {
                return TxComposer.deserialize(txComposerSerialized);
            });
        }

        // ‰ΩøÁî® Asset ÂàõÂª∫ Pin
        async function createPinWithAsset(metaidData, options) {
            const address = await window.metaidwallet.getAddress();

            let utxo = options?.utxo;
            if (!utxo) {
                const utxos = await window.metaidwallet.getUtxos();
                utxo = utxos.find(u => u.address === address);

                if (!utxo) {
                    const url = `${options.assistDomain}/v1/assist/gas/mvc/address-init`;
                    const preRes = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            gasChain: 'mvc',
                            address,
                        }),
                    });
                    const initUtxo = await preRes.json();

                    if (initUtxo.error) {
                        throw new Error(initUtxo.error);
                    }

                    if (!initUtxo.data) {
                        await sleep(5000);
                        const utxos = await window.metaidwallet.getUtxos();
                        utxo = utxos.find(u => u.address === address);
                        if (!utxo) {
                            throw new Error('No UTXO found for address');
                        }
                    } else {
                        utxo = {
                            txid: initUtxo.data.txId,
                            outIndex: initUtxo.data.index,
                            value: initUtxo.data.amount,
                            address: initUtxo.data.address,
                        };
                    }
                }
            }

            const pinTxComposer = new TxComposer();
            pinTxComposer.appendP2PKHInput({
                address: new mvc.Address(address, options.network),
                satoshis: utxo.value,
                txId: utxo.txid,
                outputIndex: utxo.outIndex,
            });

            pinTxComposer.appendP2PKHOutput({
                address: new mvc.Address(address, options.network),
                satoshis: 1,
            });

            const metaidOpreturn = buildOpReturnV2(metaidData, {
                network: options?.network ?? 'testnet',
            });
            pinTxComposer.appendOpReturnOutput(metaidOpreturn);

            const changeAddress = new mvc.Address(address, options.network);
            pinTxComposer.appendP2PKHOutput({
                address: changeAddress,
                satoshis: utxo.value,
            });

            const url = `${options.assistDomain}/v1/assist/gas/mvc/pre`;
            const preRes = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    txHex: pinTxComposer.getRawHex(),
                    address,
                }),
            });
            const preData = await preRes.json();

            if (preData.error) {
                throw new Error(preData.error);
            }

            const tx = new mvc.Transaction(preData.data.txHex);
            const txObj = tx.toObject();
            const inputs = txObj.inputs;
            console.log('inputs', inputs);

            // Ëé∑ÂèñÊâÄÊúâÂºïÁî®ÁöÑUTXO‰ø°ÊÅØ
            const utxoPromises = txObj.inputs.map(async (input) => {
                let utxoRawUrl = `https://mvcapi${
                    options.network === 'testnet' ? '-testnet' : ''
                }.cyber3.space/tx/${input.prevTxId}/raw`;

                if (options.network !== 'testnet') {
                    utxoRawUrl = `https://api.microvisionchain.com/open-api-mvc/tx/${input.prevTxId}/raw`;
                }

                const utxoRes = await fetch(utxoRawUrl);
                return await utxoRes.json();
            });
            const _utxos = await Promise.all(utxoPromises);

            // ‰∏∫ÊØè‰∏™inputËÆæÁΩÆÊ≠£Á°ÆÁöÑoutput
            tx.inputs.forEach((input, index) => {
                const _tx = new mvc.Transaction(_utxos[index].hex);
                const utxoOutput = _tx.outputs[input.outputIndex];
                tx.inputs[index].output = new mvc.Transaction.Output({
                    script: utxoOutput.script,
                    satoshis: utxoOutput.satoshis,
                });
            });

            const txComposer = new TxComposer(tx);
            const txComposerSerialize = txComposer.serialize();
            const params = {
                transaction: [
                    {
                        txComposer: txComposerSerialize,
                        toSignInputs: [0],
                    },
                ],
            };

            const [_txComposerSerialize] = await window.metaidwallet.unlockP2PKHInput(params);

            const commitUrl = `${options.assistDomain}/v1/assist/gas/mvc/commit`;
            const commitRes = await fetch(commitUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    txHex: TxComposer.deserialize(_txComposerSerialize).getRawHex(),
                    orderId: preData.data.orderId,
                }),
            });
            const commitData = await commitRes.json();

            if (commitData.code == 1 && !commitData.data) {
                throw new Error(
                    JSON.stringify({
                        state: commitData.code,
                        message: commitData.message,
                    })
                );
            }

            return {
                txid: commitData.data.txId,
                utxo: {
                    txid: commitData.data.txId,
                    outIndex: 2,
                    value: utxo.value,
                    address: address,
                },
            };
        }

        // ÂàõÂª∫ Pin
        async function createPin(metaidData, options) {
            const transactions = options?.transactions ?? [];
            const address = await window.metaidwallet.getAddress();

            const pinTxComposer = new TxComposer();

            pinTxComposer.appendP2PKHOutput({
                address: new mvc.Address(address, options.network),
                satoshis: 1,
            });

            const metaidOpreturn = buildOpReturnV2(metaidData, {
                network: options?.network ?? 'testnet'
            });

            pinTxComposer.appendOpReturnOutput(metaidOpreturn);

            if (options?.service && options?.service.address && options?.service.satoshis) {
                pinTxComposer.appendP2PKHOutput({
                    address: new mvc.Address(options.service.address, options.network),
                    satoshis: Number(options.service.satoshis),
                });
            }

            if (options?.outputs) {
                for (const output of options.outputs) {
                    pinTxComposer.appendP2PKHOutput({
                        address: new mvc.Address(output.address, options.network),
                        satoshis: Number(output.satoshis),
                    });
                }
            }

            transactions.push({
                txComposer: pinTxComposer,
                message: 'Create Pin',
            });

            if (options?.serialAction === 'combo') {
                return { transactions };
            }

            // Â∫îÁî®ÊîØ‰ªò
            const payRes = await pay({
                transactions,
                feeb: options?.feeRate,
            });

            await batchBroadcast({ txComposer: payRes, network: options.network });

            return {
                txid: payRes[payRes.length - 1].getTxId(),
                txids: payRes.map(item => item.getTxId()),
            };
        }

        // ÂàõÂª∫ÊàñÊõ¥Êñ∞Áî®Êà∑‰ø°ÊÅØ
        async function createOrUpdateUserInfo({ userData, oldUserData, options }) {
            const metaDatas = [];

            if (userData.name) {
                metaDatas.push({
                    operation: oldUserData.nameId ? 'modify' : 'create',
                    body: userData.name,
                    path: oldUserData.nameId ? `@${oldUserData.nameId}` : '/info/name',
                    encoding: 'utf-8',
                    contentType: 'text/plain',
                    flag: 'metaid',
                });
            }

            if (userData.bio) {
                metaDatas.push({
                    operation: oldUserData.bioId ? 'modify' : 'create',
                    body: userData.bio,
                    path: oldUserData.bioId ? `@${oldUserData.bioId}` : '/info/bio',
                    encoding: 'utf-8',
                    contentType: 'text/plain',
                    flag: 'metaid',
                });
            }

            if (userData.avatar) {
                metaDatas.push({
                    operation: oldUserData.avatarId ? 'modify' : 'create',
                    body: userData.avatar,
                    path: oldUserData.avatarId ? `@${oldUserData.avatarId}` : '/info/avatar',
                    encoding: 'base64',
                    contentType: 'image/jpeg;binary',
                    flag: 'metaid',
                });
            }

            if (userData.background) {
                metaDatas.push({
                    operation: oldUserData.backgroundId ? 'modify' : 'create',
                    body: userData.background,
                    path: oldUserData.backgroundId ? `@${oldUserData.backgroundId}` : '/info/background',
                    encoding: 'base64',
                    contentType: 'image/jpeg;binary',
                    flag: 'metaid',
                });
            }

            if (userData.chatpubkey) {
                if (!oldUserData.chatpubkey) {
                    metaDatas.push({
                        operation: 'create',
                        body: userData.chatpubkey,
                        path: `/info/chatpubkey`,
                        encoding: 'utf-8',
                        contentType: 'text/plain',
                        flag: 'metaid',
                    });
                }
            }

            if (metaDatas.length === 0) {
                throw new Error('No user data provided to create user info');
            }

            let _transactions = [];
            let _txids = [];

            if (options.assistDomain && !oldUserData.nameId) {
                let utxo;
                for (let i = 0; i < metaDatas.length; i++) {
                    const metaData = metaDatas[i];
                    const _options = {
                        network: options?.network ?? 'testnet',
                        signMessage: 'create User Info',
                        serialAction: 'finish',
                        assistDomain: options.assistDomain,
                    };

                    if (utxo) {
                        _options.utxo = utxo;
                    }

                    const { txid, utxo: _utxo } = await createPinWithAsset(metaData, _options);
                    utxo = _utxo;

                    if (txid) {
                        _txids.push(txid);
                    }
                }
            } else {
                for (let i = 0; i < metaDatas.length; i++) {
                    const metaData = metaDatas[i];
                    const { transactions, txid, txids } = await createPin(metaData, {
                        network: options?.network ?? 'testnet',
                        signMessage: 'create User Info',
                        serialAction: i === metaDatas.length - 1 ? 'finish' : 'combo',
                        transactions: [..._transactions],
                        feeRate: options?.feeRate,
                    });
                    _transactions = transactions;
                    if (txids) {
                        _txids = txids;
                    }
                }
            }

            const ret = {
                nameRes: undefined,
                bioRes: undefined,
                avatarRes: undefined,
                backgroundRes: undefined,
                chatpubkeyRes: undefined,
            };

            const userInfos = [
                { key: 'name', resKey: 'nameRes' },
                { key: 'bio', resKey: 'bioRes' },
                { key: 'avatar', resKey: 'avatarRes' },
                { key: 'background', resKey: 'backgroundRes' },
                { key: 'chatpubkey', resKey: 'chatpubkeyRes' },
            ];

            for (let i = 0; i < userInfos.length; i++) {
                const { key, resKey } = userInfos[i];
                if (userData[key]) {
                    const txid = _txids.shift();
                    ret[resKey] = { txid };
                }
            }

            return ret;
        }

        // ÂàõÂª∫Áî®Êà∑ÂÖ¨Èí•
        async function createUserPubkey({ pubkey, pubkeyId, options }) {
            const metaDatas = [];

            if (pubkey) {
                const hasPubkey = !!pubkeyId;
                const path = hasPubkey && pubkeyId
                    ? `@{${pubkeyId}}`
                    : `/info/chatpubkey`;

                metaDatas.push({
                    operation: hasPubkey ? 'modify' : 'create',
                    body: pubkey,
                    path: path,
                    encoding: 'utf-8',
                    contentType: 'text/plain',
                    flag: 'metaid',
                });
            } else {
                throw new Error('No Publickey provided to create user info');
            }

            if (metaDatas.length === 0) {
                throw new Error('No user data provided to publickey');
            }

            let _transactions = [];
            let _txids = [];

            for (let i = 0; i < metaDatas.length; i++) {
                const metaData = metaDatas[i];
                const { transactions, txid, txids } = await createPin(metaData, {
                    network: options?.network ?? 'testnet',
                    signMessage: 'create User Info',
                    serialAction: i === metaDatas.length - 1 ? 'finish' : 'combo',
                    transactions: [..._transactions],
                    feeRate: options?.feeRate,
                });
                _transactions = transactions;
                if (txids) {
                    _txids = txids;
                }
            }

            return _txids[0];
        }

        // Ëé∑Âèñ MVC Â•ñÂä±
        async function getMVCRewards(params, signature, options = {}) {
            const response = await fetch(
                'https://www.metaso.network/assist-open-api/v1/assist/gas/mvc/address-reward',
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Signature': signature['X-Signature'] || '',
                        'X-Public-Key': signature['X-Public-Key'] || '',
                        ...(options?.headers || {}),
                    },
                    body: JSON.stringify(params),
                    ...options,
                }
            );
            return response.json();
        }

        // ==================== ÂõæÁâáÂ§ÑÁêÜÁõ∏ÂÖ≥ÂáΩÊï∞ ====================

        // ÂéãÁº©ÂõæÁâá
        async function compressImage(image) {
            const options = {
                maxSizeMB: 0.3,
                maxWidthOrHeight: 2048,
                useWebWorker: true,
            };
            const compressedFile = await imageCompression(image, options);
            return compressedFile;
        }

        // Êñá‰ª∂ËΩ¨Êç¢‰∏∫ AttachmentItem
        function FileToAttachmentItem(file, encrypt = 0) {
            return new Promise(async resolve => {
                function readResult(blob) {
                    return new Promise(resolve => {
                        const reader = new FileReader();
                        reader.onload = () => {
                            const wordArray = CryptoJS.lib.WordArray.create(reader.result);
                            const buffer = Buffer.from(reader.result);
                            hex += buffer.toString('hex'); // Êõ¥Êñ∞hex
                            sha256Algo.update(wordArray); // Êõ¥Êñ∞hash
                            resolve();
                        };
                        reader.readAsArrayBuffer(blob);
                    });
                }

                // ÂàÜÂùóËØªÂèñÔºåÈò≤Ê≠¢ÂÜÖÂ≠òÊ∫¢Âá∫ÔºåËøôÈáåËÆæÁΩÆ‰∏∫20MB
                const chunkSize = 20 * 1024 * 1024;
                let hex = ''; // ‰∫åËøõÂà∂
                const sha256Algo = CryptoJS.algo.SHA256.create();

                for (let index = 0; index < file.size; index += chunkSize) {
                    await readResult(file.slice(index, index + chunkSize));
                }

                resolve({
                    data: hex,
                    fileName: file.name,
                    fileType: file.type,
                    sha256: CryptoJS.enc.Hex.stringify(sha256Algo.finalize()),
                    url: URL.createObjectURL(file),
                    encrypt,
                    size: file.size,
                });
            });
        }

        // ÂõæÁâáËΩ¨Êç¢‰∏∫ Attachment
        async function image2Attach(images) {
            const attachments = [];

            for (let i = 0; i < images.length; i++) {
                const current = images[i];
                if (!current) continue;

                // ÂéãÁº©ÂõæÁâáÔºàGIF Èô§Â§ñÔºâ
                const compressed = await compressImage(current);
                const result = await FileToAttachmentItem(
                    current.type === 'image/gif' ? current : compressed
                );
                if (result) attachments.push(result);
            }

            return attachments;
        }

        // Ëé∑Âèñ ECDH ÂÖ¨Èí•
        async function getEcdhPublickey(pubkey) {
            if (!window.metaidwallet) {
                throw new Error('Metalet wallet not found');
            }

            try {
                const ecdh = await window.metaidwallet.common.ecdh({
                    externalPubKey: pubkey || CONSTANTS.MAN_PUB_KEY,
                });
                return ecdh;
            } catch (error) {
                console.error('Failed to get ECDH public key:', error);
                return null;
            }
        }

        // ==================== Hash Ë∑ØÁî±Á≥ªÁªü ====================

        // ÂàõÂª∫ÁÆÄÂçïÁöÑ Hash Ë∑ØÁî±Á≥ªÁªüÊõø‰ª£ vue-router
        const createHashRouter = () => {
            const currentRoute = ref({
                path: '/',
                params: {},
                query: {}
            });

            const parseHash = () => {
                const hash = window.location.hash.slice(1) || '/';
                const [pathWithParams, queryString] = hash.split('?');

                // Ëß£ÊûêË∑ØÂæÑÂèÇÊï∞Ôºà‰æãÂ¶Ç /note/123Ôºâ
                const pathSegments = pathWithParams.split('/').filter(Boolean);
                const params = {};

                // Ëß£Êûê query ÂèÇÊï∞
                const query = {};
                if (queryString) {
                    queryString.split('&').forEach(param => {
                        const [key, value] = param.split('=');
                        query[decodeURIComponent(key)] = decodeURIComponent(value || '');
                    });
                }

                // ÊèêÂèñË∑ØÂæÑÂèÇÊï∞ÔºàÂ¶Ç /note/:idÔºâ
                if (pathSegments[0] === 'note' && pathSegments[1]) {
                    params.id = pathSegments[1];
                    if (pathSegments[2] === 'edit') {
                        currentRoute.value = {
                            path: `/note/${pathSegments[1]}/edit`,
                            params,
                            query
                        };
                    } else {
                        currentRoute.value = {
                            path: `/note/${pathSegments[1]}`,
                            params,
                            query
                        };
                    }
                } else {
                    currentRoute.value = {
                        path: '/' + pathSegments.join('/'),
                        params,
                        query
                    };
                }

                return currentRoute.value;
            };

            const push = (path) => {
                if (typeof path === 'object') {
                    let url = path.path || '/';
                    if (path.query) {
                        const queryStr = Object.entries(path.query)
                            .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
                            .join('&');
                        url += '?' + queryStr;
                    }
                    window.location.hash = '#' + url;
                } else {
                    window.location.hash = '#' + path;
                }
            };

            const replace = (path) => {
                const hashPath = typeof path === 'string' ? path : path.path;
                window.location.replace('#' + hashPath);
            };

            const back = () => {
                window.history.back();
            };

            // ÁõëÂê¨ hash ÂèòÂåñ
            window.addEventListener('hashchange', parseHash);

            // ÂàùÂßãËß£Êûê
            parseHash();

            return {
                currentRoute,
                push,
                replace,
                back
            };
        };

        // ÂÖ®Â±ÄË∑ØÁî±ÂÆû‰æã
        let router;

        // ==================== Âä†ÂØÜ/Ëß£ÂØÜÂ∑•ÂÖ∑ ====================

        /**
         * ÁîüÊàêÊåáÂÆöÈïøÂ∫¶ÁöÑÈöèÊú∫Â≠óËäÇÊï∞ÁªÑÔºà‰ΩøÁî®ÊµèËßàÂô® Web Crypto APIÔºâ
         */
        function randomBytes(length) {
            const buffer = new Uint8Array(length);
            crypto.getRandomValues(buffer);
            return buffer;
        }

        /**
         * Â∞ÜÂçÅÂÖ≠ËøõÂà∂Â≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫ ArrayBuffer
         */
        function hexToArrayBuffer(hex) {
            // ÁßªÈô§ÂèØËÉΩÂ≠òÂú®ÁöÑÁ©∫Ê†ºÂíåÊç¢Ë°å
            hex = hex.replace(/\s/g, '');

            if (hex.length % 2 !== 0) {
                throw new Error('ÂçÅÂÖ≠ËøõÂà∂Â≠óÁ¨¶‰∏≤ÈïøÂ∫¶ÂøÖÈ°ªÊòØÂÅ∂Êï∞');
            }

            const buffer = new ArrayBuffer(hex.length / 2);
            const view = new Uint8Array(buffer);

            for (let i = 0; i < hex.length; i += 2) {
                view[i / 2] = parseInt(hex.substring(i, i + 2), 16);
            }

            return buffer;
        }

        /**
         * Â∞Ü Uint8Array ËΩ¨Êç¢‰∏∫ÂçÅÂÖ≠ËøõÂà∂Â≠óÁ¨¶‰∏≤
         */
        function arrayToHex(array) {
            return Array.from(array)
                .map(byte => byte.toString(16).padStart(2, '0'))
                .join('');
        }

        /**
         * Â∞Ü ArrayBuffer Êàñ Uint8Array ËΩ¨Êç¢‰∏∫ base64 Â≠óÁ¨¶‰∏≤
         */
        function arrayBufferToBase64(buffer) {
            const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        /**
         * Â∞Ü base64 Â≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫ ArrayBuffer
         */
        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const buffer = new ArrayBuffer(binary.length);
            const view = new Uint8Array(buffer);
            for (let i = 0; i < binary.length; i++) {
                view[i] = binary.charCodeAt(i);
            }
            return buffer;
        }

        /**
         * ‰ΩøÁî®ÂçÅÂÖ≠ËøõÂà∂ÂØÜÈí•ËøõË°å AES-256-GCM Âä†ÂØÜÔºà‰ΩøÁî® Web Crypto APIÔºâ
         */
        async function encryptGCM(plaintext, hexKey) {
            try {
                // ÁîüÊàê 12 Â≠óËäÇÁöÑÈöèÊú∫ IV
                const iv = randomBytes(12);

                // Â∞ÜÂçÅÂÖ≠ËøõÂà∂ÂØÜÈí•ËΩ¨Êç¢‰∏∫ ArrayBuffer
                const keyBuffer = hexToArrayBuffer(hexKey);

                // Ê£ÄÊü•ÂØÜÈí•ÈïøÂ∫¶ (AES-256 ÈúÄË¶Å 32 Â≠óËäÇ)
                if (keyBuffer.byteLength !== 32) {
                    throw new Error(`ÂØÜÈí•ÈïøÂ∫¶ÈîôËØØÔºåÊúüÊúõ32Â≠óËäÇÔºåÂÆûÈôÖ${keyBuffer.byteLength}Â≠óËäÇ`);
                }

                // ÂØºÂÖ•ÂØÜÈí•
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    keyBuffer,
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt']
                );

                // Â∞ÜÊòéÊñáËΩ¨Êç¢‰∏∫ Uint8Array
                const encoder = new TextEncoder();
                const plaintextBuffer = encoder.encode(plaintext);

                // Âä†ÂØÜ
                const encryptedBuffer = await crypto.subtle.encrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv,
                        tagLength: 128 // 16 Â≠óËäÇÁöÑËÆ§ËØÅÊ†áÁ≠æ
                    },
                    cryptoKey,
                    plaintextBuffer
                );

                // ÁªÑÂêà iv + ÂØÜÊñáÔºàÂØÜÊñáÂ∑≤ÂåÖÂê´ËÆ§ËØÅÊ†áÁ≠æÔºâ
                const resultBuffer = new Uint8Array(iv.length + encryptedBuffer.byteLength);
                resultBuffer.set(iv, 0);
                resultBuffer.set(new Uint8Array(encryptedBuffer), iv.length);

                // ËΩ¨Êç¢‰∏∫ base64
                return arrayBufferToBase64(resultBuffer);
            } catch (error) {
                throw new Error(`AES Âä†ÂØÜÂ§±Ë¥•: ${error instanceof Error ? error.message : String(error)}`);
            }
        }

        /**
         * ‰ΩøÁî®ÂçÅÂÖ≠ËøõÂà∂ÂØÜÈí•ËøõË°å AES-256-GCM Ëß£ÂØÜÔºà‰ΩøÁî® Web Crypto APIÔºâ
         */
        async function decryptGCM(ciphertext, hexKey) {
            try {
                // Ëß£Á†Å base64
                const data = base64ToArrayBuffer(ciphertext);

                // Â∞ÜÂçÅÂÖ≠ËøõÂà∂ÂØÜÈí•ËΩ¨Êç¢‰∏∫ ArrayBuffer
                const keyBuffer = hexToArrayBuffer(hexKey);

                // Ê£ÄÊü•ÂØÜÈí•ÈïøÂ∫¶ (AES-256 ÈúÄË¶Å 32 Â≠óËäÇ)
                if (keyBuffer.byteLength !== 32) {
                    throw new Error(`ÂØÜÈí•ÈïøÂ∫¶ÈîôËØØÔºåÊúüÊúõ32Â≠óËäÇÔºåÂÆûÈôÖ${keyBuffer.byteLength}Â≠óËäÇ`);
                }

                // Ê£ÄÊü•Êï∞ÊçÆÈïøÂ∫¶ (Ëá≥Â∞ëÈúÄË¶Å iv + authTag)
                if (data.byteLength < 28) { // 12 (iv) + 16 (authTag) = 28
                    throw new Error('ÂØÜÊñáÊï∞ÊçÆÂ§™Áü≠');
                }

                // ÊèêÂèñ IV (Ââç 12 Â≠óËäÇ)
                const iv = data.slice(0, 12);

                // ÊèêÂèñÂØÜÊñáÔºàÂåÖÂê´ËÆ§ËØÅÊ†áÁ≠æÔºå‰ªéÁ¨¨ 12 Â≠óËäÇÂà∞ÁªìÂ∞æÔºâ
                const encryptedData = data.slice(12);

                // ÂØºÂÖ•ÂØÜÈí•
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    keyBuffer,
                    { name: 'AES-GCM' },
                    false,
                    ['decrypt']
                );

                // Ëß£ÂØÜ
                const decryptedBuffer = await crypto.subtle.decrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv,
                        tagLength: 128 // 16 Â≠óËäÇÁöÑËÆ§ËØÅÊ†áÁ≠æ
                    },
                    cryptoKey,
                    encryptedData
                );

                // Â∞ÜËß£ÂØÜÂêéÁöÑ ArrayBuffer ËΩ¨Êç¢‰∏∫Â≠óÁ¨¶‰∏≤
                const decoder = new TextDecoder();
                return decoder.decode(decryptedBuffer);
            } catch (error) {
                throw new Error(`AES Ëß£ÂØÜÂ§±Ë¥•: ${error instanceof Error ? error.message : String(error)}`);
            }
        }

        /**
         * ÁîüÊàêÈöèÊú∫ AES-256 ÂØÜÈí• (ÂçÅÂÖ≠ËøõÂà∂Ê†ºÂºè)
         */
        function generateAESKey() {
            const key = randomBytes(32); // 32 Â≠óËäÇ = 256 ‰Ωç
            return arrayToHex(key);
        }

        // ==================== Crypto Store ====================

        /**
         * Ëé∑ÂèñÂΩìÂâçÁî®Êà∑ÁöÑÁ≠æÂêçÂØÜÈí•
         */
        function queryCurrentSigKey() {
            const userStore = useUserStore();
            if (!userStore.last?.address) {
                return null;
            }

            try {
                const signKeysData = localStorage.getItem('signKeys');
                if (!signKeysData) {
                    return null;
                }

                const signKeys = JSON.parse(signKeysData);
                const signData = signKeys.find(item => item.address === userStore.last.address);
                return signData ? signData.sigKey : null;
            } catch (error) {
                console.error('ËØªÂèñ signKeys Â§±Ë¥•:', error);
                return null;
            }
        }

        /**
         * Á≠æÂêçÊ∂àÊÅØÂπ∂Â≠òÂÇ®Âà∞ localStorage
         */
        async function signMessageAndStore() {
            try {
                const userStore = useUserStore();

                if (!userStore.last?.address) {
                    throw new Error('Áî®Êà∑Âú∞ÂùÄ‰∏çÂ≠òÂú®');
                }

                if (!window.metaidwallet?.signMessage) {
                    throw new Error('metaidwallet.signMessage ÊñπÊ≥ï‰∏çÂèØÁî®');
                }

                const message = userStore.last.address;
                const { signature } = await window.metaidwallet.signMessage(message);

                // ‰ªé localStorage Ëé∑ÂèñÁé∞ÊúâÁöÑ signKeys Êï∞ÁªÑ
                const existingSignKeys = localStorage.getItem('signKeys');
                let signKeys = existingSignKeys ? JSON.parse(existingSignKeys) : [];

                // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®Áõ∏ÂêåÂú∞ÂùÄÁöÑÁ≠æÂêç
                const existingIndex = signKeys.findIndex(item => item.address === message);
                const signItem = {
                    address: message,
                    sigKey: signature.signature.slice(0, 64)
                };

                if (existingIndex >= 0) {
                    // Êõ¥Êñ∞Áé∞ÊúâÁ≠æÂêç
                    signKeys[existingIndex] = signItem;
                } else {
                    // Ê∑ªÂä†Êñ∞Á≠æÂêç
                    signKeys.push(signItem);
                }

                // Â≠òÂÇ®Âà∞ localStorage
                localStorage.setItem('signKeys', JSON.stringify(signKeys));

                return signature.signature.slice(0, 64);
            } catch (error) {
                console.error('Á≠æÂêçÊ∂àÊÅØÂ§±Ë¥•:', error);
                throw error;
            }
        }

        // ==================== MAN V2 API ====================

        // Simplenote ÂçèËÆÆË∑ØÂæÑ
        const SIMPLENOTE_PROTOCOL_PATH = '/protocols/simplenote';

        // MAN V2 API Âü∫Á°ÄURL
        const MAN_V2_BASE_URL = CONSTANTS.MAN_V2_BASE_URL;

        // MAN V2 API ÂÆû‰æã
        const manV2Api = new HttpRequest(MAN_V2_BASE_URL, {
            responseHandler: ({ data }) => {
                return new Promise((resolve, reject) => {
                    if (data && typeof data.code === 'number') {
                        if (data.code === 1 || data.code === 200) {
                            resolve(data.data);
                        } else {
                            reject({
                                code: data.code,
                                data: data.data,
                                message: data.message,
                            });
                        }
                    } else {
                        resolve(data.data || data);
                    }
                });
            },
        });

        // Ëé∑ÂèñÊåáÂÆö path ‰∏ãÊâÄÊúâ PinÔºàÂàÜÈ°µÔºâ
        async function getPinListByPath(params) {
            const { cursor = 0, size = 20, path } = params;
            const query = new URLSearchParams({
                cursor: cursor.toString(),
                size: size.toString(),
                path
            }).toString();
            return manV2Api.get('/pin/path/list' + `?${query}`);
        }

        // Ëé∑Âèñ Pin ËØ¶ÊÉÖ
        async function getPinDetail(params) {
            const { numberOrId } = params;
            return manV2Api.get(`/pin/${numberOrId}`);
        }

        // ==================== Simplenote API ====================

        // Ëé∑ÂèñÁ¨îËÆ∞ÂàóË°®
        async function getNoteList(params = {}) {
            const { cursor = 0, size = 20 } = params;

            try {
                const response = await getPinListByPath({
                    path: SIMPLENOTE_PROTOCOL_PATH,
                    cursor,
                    size
                });

                return response;
            } catch (error) {
                console.error('Ëé∑ÂèñÁ¨îËÆ∞ÂàóË°®Â§±Ë¥•:', error);
                throw error;
            }
        }

        // Ëé∑ÂèñÁ¨îËÆ∞ËØ¶ÊÉÖ
        async function getNoteDetail(pinId) {
            try {
                const pin = await getPinDetail({ numberOrId: pinId });

                // Ëß£ÊûêÁ¨îËÆ∞ÂÜÖÂÆπ
                let noteData;
                try {
                    noteData = typeof pin.contentSummary === 'string'
                        ? JSON.parse(pin.contentSummary)
                        : pin.contentSummary;
                } catch {
                    throw new Error('Êó†Ê≥ïËß£ÊûêÁ¨îËÆ∞Êï∞ÊçÆ');
                }

                return {
                    pin,
                    noteData
                };
            } catch (error) {
                console.error('Ëé∑ÂèñÁ¨îËÆ∞ËØ¶ÊÉÖÂ§±Ë¥•:', error);
                throw error;
            }
        }

        // Ê†πÊçÆÂú∞ÂùÄËé∑ÂèñÁî®Êà∑‰ø°ÊÅØ
        async function getUserInfoByAddress(address) {
            try {
                const response = await manApi.get(`/info/address/${address}`);
                return response;
            } catch (error) {
                console.error('Ëé∑ÂèñÁî®Êà∑‰ø°ÊÅØÂ§±Ë¥•:', error);
                return null;
            }
        }

        // ÂàõÂª∫Á¨îËÆ∞
        async function createNote(params) {
            const { noteData, attachments = [], options = {} } = params;
            const { showToast } = useToast();
            const userStore = useUserStore();
            const chainStore = useChainStore();
            const networkStore = useNetworkStore();

            try {
                if (!userStore.isAuthorized) {
                    throw new Error('ËØ∑ÂÖàËøûÊé•Èí±ÂåÖ');
                }

                // Á≠âÂæÖ waitForMetaIDJs Âä†ËΩΩ
                await waitForMetaIDJs();

                // ÊûÑÂª∫Á¨îËÆ∞Êï∞ÊçÆ
                const finalNoteData = {
                    title: noteData.title || '',
                    subtitle: noteData.subtitle || '',
                    content: noteData.content || '',
                    contentType: noteData.contentType || 'text/markdown',
                    encryption:noteData.encryption || "0",
                    coverImg:noteData.coverImg || '',
                    createTime: noteData.createTime || Date().now(),
                    tags: noteData.tags || [],
                    attachments: noteData.attachments || []
                };

                // Ëé∑ÂèñÂΩìÂâçÈìæÂíåË¥πÁéá
                const currentChain = chainStore.state.currentChain;
                const chainData = chainStore.state[currentChain];
                const selectedFeeType = chainData.selectedFeeType;
                const feeRate = chainData[selectedFeeType];
                const network = networkStore.network;

                // ÂàõÂª∫ Pin
                const result = await createPin(
                    {
                        operation: 'create',
                        body: JSON.stringify(finalNoteData),
                        path: '/protocols/simplenote',
                        contentType: 'application/json',
                        encoding: 'utf-8',
                        version: '1.0.0'
                    },
                    {
                        network,
                        feeRate,
                        service: options.service
                    }
                );

                console.log('Á¨îËÆ∞ÂàõÂª∫ÊàêÂäü:', result);
                return result;
            } catch (error) {
                console.error('ÂàõÂª∫Á¨îËÆ∞Â§±Ë¥•:', error);
                throw error;
            }
        }

        // Êõ¥Êñ∞Á¨îËÆ∞
        async function updateNote(params) {
            const { pinId, noteData, attachments = [], options = {} } = params;
            const { showToast } = useToast();
            const userStore = useUserStore();
            const chainStore = useChainStore();
            const networkStore = useNetworkStore();

            try {
                if (!userStore.isAuthorized) {
                    throw new Error('ËØ∑ÂÖàËøûÊé•Èí±ÂåÖ');
                }

                if (!pinId) {
                    throw new Error('Á¨îËÆ∞ID‰∏çËÉΩ‰∏∫Á©∫');
                }

                // Á≠âÂæÖ waitForMetaIDJs Âä†ËΩΩ
                await waitForMetaIDJs();

                // ÊûÑÂª∫Á¨îËÆ∞Êï∞ÊçÆ
                const finalNoteData = {
                    title: noteData.title || '',
                    subtitle: noteData.subtitle || '',
                    content: noteData.content || '',
                    contentType: noteData.contentType || 'text/markdown',
                    encryption:noteData.encryption || "0",
                    coverImg:noteData.coverImg || '',
                    createTime: noteData.createTime || Date().now(),
                    tags: noteData.tags || [],
                    attachments: noteData.attachments || []
                };

                // Ëé∑ÂèñÂΩìÂâçÈìæÂíåË¥πÁéá
                const currentChain = chainStore.state.currentChain;
                const chainData = chainStore.state[currentChain];
                const selectedFeeType = chainData.selectedFeeType;
                const feeRate = chainData[selectedFeeType];
                const network = networkStore.network;

                // Êõ¥Êñ∞ PinÔºàmodify Êìç‰ΩúÔºâ
                const result = await createPin(
                    {
                        operation: 'modify',
                        body: JSON.stringify(finalNoteData),
                        path: `@${pinId}`,
                        contentType: 'application/json',
                        encoding: 'utf-8',
                        version: '1.0.0'
                    },
                    {
                        network,
                        feeRate,
                        service: options.service
                    }
                );

                console.log('Á¨îËÆ∞Êõ¥Êñ∞ÊàêÂäü:', result);
                return result;
            } catch (error) {
                console.error('Êõ¥Êñ∞Á¨îËÆ∞Â§±Ë¥•:', error);
                throw error;
            }
        }

        function hexToUint8Array(hexString) {
        // ÁßªÈô§ÂèØËÉΩÂ≠òÂú®ÁöÑÁ©∫Ê†ºÊàñÂâçÁºÄÔºàÂ¶Ç0xÔºâ
        hexString = hexString.replace(/^0x|\s/g, '')

        // Á°Æ‰øùÈïøÂ∫¶‰∏∫ÂÅ∂Êï∞
        if (hexString.length % 2 !== 0) {
        throw new Error('Hex string must have an even length')
        }

        const length = hexString.length / 2
        const array = new Uint8Array(length)

        for (let i = 0; i < length; i++) {
        const byteHex = hexString.substr(i * 2, 2)
        array[i] = parseInt(byteHex, 16)
        }

        return array
        }

        function hexToBase64(hexString) {
        // ÁßªÈô§ÂèØËÉΩÂ≠òÂú®ÁöÑÁ©∫Ê†ºÂíåÂâçÁºÄ
        const cleanHex = hexString.replace(/\s/g, '').replace(/^0x/, '')

        // È™åËØÅÊòØÂê¶‰∏∫ÊúâÊïàÁöÑÂçÅÂÖ≠ËøõÂà∂Â≠óÁ¨¶‰∏≤
        if (!/^[0-9A-Fa-f]*$/.test(cleanHex)) {
        throw new Error('Invalid hexadecimal string')
        }

        // Á°Æ‰øùÂçÅÂÖ≠ËøõÂà∂Â≠óÁ¨¶‰∏≤ÈïøÂ∫¶‰∏∫ÂÅ∂Êï∞
        const paddedHex = cleanHex.length % 2 === 0 ? cleanHex : '0' + cleanHex

        // Â∞ÜÂçÅÂÖ≠ËøõÂà∂Â≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫Â≠óËäÇÊï∞ÁªÑ
        const byteArray = []
        for (let i = 0; i < paddedHex.length; i += 2) {
        byteArray.push(parseInt(paddedHex.substr(i, 2), 16))
        }

        // Â∞ÜÂ≠óËäÇÊï∞ÁªÑËΩ¨Êç¢‰∏∫‰∫åËøõÂà∂Â≠óÁ¨¶‰∏≤
        const binaryString = byteArray.map(byte => String.fromCharCode(byte)).join('')

        // ‰ΩøÁî®btoaÂáΩÊï∞Â∞Ü‰∫åËøõÂà∂Â≠óÁ¨¶‰∏≤ËΩ¨Êç¢‰∏∫Base64
        return btoa(binaryString)
        }

        // ‰∏ä‰º†Êñá‰ª∂Âà∞Èìæ‰∏ä
        async function createFileOnChain(params) {
            const { file, options = {} } = params;
            const userStore = useUserStore();
            const chainStore = useChainStore();
            const networkStore = useNetworkStore();

            try {
                if (!userStore.isAuthorized) {
                    throw new Error('ËØ∑ÂÖàËøûÊé•Èí±ÂåÖ');
                }

                // Á≠âÂæÖ waitForMetaIDJs Âä†ËΩΩ
                await waitForMetaIDJs();

                // ËØªÂèñÊñá‰ª∂‰∏∫ ArrayBuffer
                const arrayBuffer = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = () => reject(new Error('Êñá‰ª∂ËØªÂèñÂ§±Ë¥•'));
                    reader.readAsArrayBuffer(file);
                });

                // ËΩ¨Êç¢‰∏∫ hex Â≠óÁ¨¶‰∏≤
                const uint8Array = new Uint8Array(arrayBuffer);
                const hexString = Array.from(uint8Array)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');

                // ËÆ°ÁÆó SHA256
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const sha256 = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                // Ëé∑ÂèñÊñá‰ª∂Âêç
                const fileName = file.name || 'unnamed_file';

                // Ëé∑ÂèñÂΩìÂâçÈìæÂíåË¥πÁéá
                const currentChain = chainStore.state.currentChain;
                const chainData = chainStore.state[currentChain];
                const selectedFeeType = chainData.selectedFeeType;
                const feeRate = chainData[selectedFeeType];
                const network = networkStore.network;

                // ÂàõÂª∫Êñá‰ª∂ Pin
                const result = await createPin(
                    {
                        operation: 'create',
                        body:currentChain == 'mvc' ? hexToUint8Array(hexString) : hexToBase64(hexString),
                        path: '/file',
                        contentType: file.type || 'application/octet-stream',
                        encoding: currentChain == 'mvc' ? 'binary' : 'base64'  ,
                        version: '1.0.0'
                    },
                    {
                        network,
                        feeRate,
                        service: options.service
                    }
                );

                console.log('Êñá‰ª∂‰∏ä‰º†ÊàêÂäü:', result);
                return result;
            } catch (error) {
                console.error('Êñá‰ª∂‰∏ä‰º†Â§±Ë¥•:', error);
                throw error;
            }
        }

        // ‰∏ä‰º†Êñá‰ª∂Âπ∂ËøîÂõû pinId
        async function uploadFile(file) {
            try {
                const result = await createFileOnChain({ file, options: {} });

                if (result && result.txid) {
                    // ËøîÂõû txid + i0 Ê†ºÂºèÁöÑ pinId
                    return `${result.txid}i0`;
                } else {
                    throw new Error('Êñá‰ª∂‰∏ä‰º†Â§±Ë¥•');
                }
            } catch (error) {
                console.error('Upload file error:', error);
                throw error;
            }
        }

        // Âà†Èô§Á¨îËÆ∞
        // async function deleteNote(pinId, options = {}) {
        //     const { showToast } = useToast();
        //     const userStore = useUserStore();
        //     const chainStore = useChainStore();
        //     const networkStore = useNetworkStore();

        //     try {
        //         if (!userStore.isAuthorized) {
        //             throw new Error('ËØ∑ÂÖàËøûÊé•Èí±ÂåÖ');
        //         }

        //         if (!pinId) {
        //             throw new Error('Á¨îËÆ∞ID‰∏çËÉΩ‰∏∫Á©∫');
        //         }

        //         // Á≠âÂæÖ meta-contract Âä†ËΩΩ
        //         await waitForMetaContract();

        //         // Ëé∑ÂèñÂΩìÂâçÈìæÂíåË¥πÁéá
        //         const currentChain = chainStore.state.currentChain;
        //         const chainData = chainStore.state[currentChain];
        //         const selectedFeeType = chainData.selectedFeeType;
        //         const feeRate = chainData[selectedFeeType];
        //         const network = networkStore.network;

        //         // Êí§ÈîÄ PinÔºàrevoke Êìç‰ΩúÔºâ
        //         const result = await createPin(
        //             {
        //                 operation: 'revoke',
        //                 body: '',
        //                 path: `@${pinId}`,
        //                 contentType: 'text/plain',
        //                 encoding: 'utf-8',
        //                 version: '1.0.0'
        //             },
        //             {
        //                 network,
        //                 feeRate,
        //                 service: options.service
        //             }
        //         );

        //         console.log('Á¨îËÆ∞Âà†Èô§ÊàêÂäü:', result);
        //         return result;
        //     } catch (error) {
        //         console.error('Âà†Èô§Á¨îËÆ∞Â§±Ë¥•:', error);
        //         throw error;
        //     }
        // }

        // ==================== IndexedDB Draft Management ====================
        // Draft database using Dexie
        class DraftDatabase extends Dexie {
            constructor() {
                super('IDNoteDB');

                this.version(1).stores({
                    drafts: '++id, updatedAt, pinId',
                    mediaFiles: '++id, draftId, blobUrl, pinId'
                });
            }

            // ‰øùÂ≠òÊàñÊõ¥Êñ∞ËçâÁ®ø
            async saveDraft(draft) {
                const now = Date.now();
                // Á°Æ‰øùÊâÄÊúâÊï∞ÊçÆÈÉΩÊòØÂèØÂ∫èÂàóÂåñÁöÑÁ∫ØÊï∞ÊçÆÔºàÈÅøÂÖçDataCloneErrorÔºâ
                const draftData = {
                    title: String(draft.title || ''),
                    subtitle: String(draft.subtitle || ''),
                    coverImg: String(draft.coverImg || ''),
                    content: String(draft.content || ''),
                    tags: Array.isArray(draft.tags)
                        ? draft.tags.map(tag => typeof tag === 'string' ? tag : String(tag))
                        : [],
                    updatedAt: now,
                    createdAt: draft.id ? (await this.drafts.get(draft.id))?.createdAt || now : now,
                    pinId: String(draft.pinId || '')
                };

                if (draft.id) {
                    await this.drafts.update(draft.id, draftData);
                    return draft.id;
                } else {
                    return await this.drafts.add(draftData);
                }
            }

            // Ëé∑ÂèñÊâÄÊúâËçâÁ®øÔºàÊåâÊõ¥Êñ∞Êó∂Èó¥ÂÄíÂ∫èÔºâ
            async getAllDrafts() {
                return await this.drafts.orderBy('updatedAt').reverse().toArray();
            }

            // Ëé∑ÂèñÂçï‰∏™ËçâÁ®ø
            async getDraft(id) {
                return await this.drafts.get(id);
            }

            // Âà†Èô§ËçâÁ®ø
            async deleteDraft(id) {
                // ÂêåÊó∂Âà†Èô§ÂÖ≥ËÅîÁöÑÂ™í‰ΩìÊñá‰ª∂
                const mediaFiles = await this.mediaFiles.where('draftId').equals(id).toArray();
                for (const media of mediaFiles) {
                    // ÈáäÊîæ blob URLÔºà‰ªÖÈíàÂØπÊóßÊï∞ÊçÆÔºåÊñ∞Êï∞ÊçÆ‰ΩøÁî® data URL Êó†ÈúÄÊâãÂä®ÈáäÊîæÔºâ
                    if (media.blobUrl && media.blobUrl.startsWith('blob:')) {
                        URL.revokeObjectURL(media.blobUrl);
                    }
                }
                await this.mediaFiles.where('draftId').equals(id).delete();
                await this.drafts.delete(id);
            }

            // ‰øùÂ≠òÂ™í‰ΩìÊñá‰ª∂
            async saveMediaFile(mediaFile) {
                return await this.mediaFiles.add({
                    draftId: mediaFile.draftId,
                    blobUrl: mediaFile.blobUrl,
                    file: mediaFile.file,
                    type: mediaFile.type,
                    name: mediaFile.name,
                    mediaId: mediaFile.mediaId, // ‰øùÂ≠ò‰∏¥Êó∂mediaId
                    createdAt: Date.now(),
                    pinId: mediaFile.pinId || ''
                });
            }

            // Ëé∑ÂèñËçâÁ®øÁöÑÊâÄÊúâÂ™í‰ΩìÊñá‰ª∂
            async getMediaFilesByDraftId(draftId) {
                return await this.mediaFiles.where('draftId').equals(draftId).toArray();
            }

            // Êõ¥Êñ∞Â™í‰ΩìÊñá‰ª∂ÁöÑ PINID
            async updateMediaFilePinId(id, pinId) {
                await this.mediaFiles.update(id, { pinId });
            }

            // Âà†Èô§Â™í‰ΩìÊñá‰ª∂
            async deleteMediaFile(id) {
                const media = await this.mediaFiles.get(id);
                // ÈáäÊîæ blob URLÔºà‰ªÖÈíàÂØπÊóßÊï∞ÊçÆÔºåÊñ∞Êï∞ÊçÆ‰ΩøÁî® data URL Êó†ÈúÄÊâãÂä®ÈáäÊîæÔºâ
                if (media && media.blobUrl && media.blobUrl.startsWith('blob:')) {
                    URL.revokeObjectURL(media.blobUrl);
                }
                await this.mediaFiles.delete(id);
            }

            // Ê†πÊçÆ PINID Âà†Èô§ËçâÁ®øÔºàÂèëÂ∏ÉÊàêÂäüÂêéÔºâ
            async deleteDraftByPinId(pinId) {
                const draft = await this.drafts.where('pinId').equals(pinId).first();
                if (draft && draft.id) {
                    await this.deleteDraft(draft.id);
                }
            }
        }

        // ÂàõÂª∫Êï∞ÊçÆÂ∫ìÂÆû‰æã
        const draftDB = new DraftDatabase();

        // ==================== Pinia Stores ====================

        // Root Store - Ê†πÁä∂ÊÄÅÁÆ°ÁêÜ
        const useRootStore = defineStore('root', {
            state: () => ({
                isWebView: false
            }),
            actions: {
                // Ê£ÄÊü•ÊòØÂê¶Âú®WebView‰∏≠
                checkWebViewBridge() {
                    const UA = window.navigator.userAgent.toLowerCase();
                    const isAndroid = !!(UA && UA.indexOf('android') > 0);
                    const isIOS = !!(UA && /iphone|ipad|ipod|ios/.test(UA));

                    if (isIOS || isAndroid) {
                        if (window?.navigator) {
                            const userAgent = window?.navigator?.userAgent || '';
                            if (userAgent === 'IDChat-iOS' || userAgent === 'IDChat-Android') {
                                this.isWebView = true;
                                return true;
                            }
                        }
                    }
                    return false;
                },

                // Ê£ÄÊü•BTCÂíåMVCÂú∞ÂùÄÊòØÂê¶‰∏ÄËá¥
                async checkBtcAddressSameAsMvc() {
                    const connectionStore = useConnectionStore();
                    const mvcAddress = await connectionStore.adapter.getMvcAddress();
                    const btcAddress = await connectionStore.adapter.getBtcAddress();

                    if (mvcAddress && btcAddress && mvcAddress !== btcAddress) {
                        throw new Error('BTC Âú∞ÂùÄ‰∏é MVC Âú∞ÂùÄ‰∏ç‰∏ÄËá¥ÔºåËØ∑Á°Æ‰øù‰ΩøÁî®Áõ∏ÂêåÁöÑÈí±ÂåÖÂú∞ÂùÄ');
                    }
                }
            }
        });

        // Network Store - ÁΩëÁªúÁä∂ÊÄÅÁÆ°ÁêÜ
        const useNetworkStore = defineStore('network', {
            getters: {
                network: () => CONSTANTS.NETWORK,
                isTestnet: () => CONSTANTS.NETWORK === 'testnet',
            }
        });

        // Layout Store - Â∏ÉÂ±ÄÁä∂ÊÄÅÁÆ°ÁêÜ
        const useLayoutStore = defineStore('layout', {
            state: () => ({
                isShowProfileEditModal: false
            })
        });

        // User Store - Áî®Êà∑‰ø°ÊÅØÁÆ°ÁêÜ
        const useUserStore = defineStore('user', {
            state: () => ({
                last: useLocalStorage('user-info', {
                    address: '',
                    avatar: '',
                    avatarId: '',
                    background: '',
                    bio: '',
                    bioId: '',
                    blocked: false,
                    chainName: 'mvc',
                    fdv: 0,
                    followCount: 0,
                    isInit: false,
                    metaid: '',
                    name: '',
                    nameId: '',
                    nftAvatar: '',
                    nftAvatarId: '',
                    number: 0,
                    pdv: 0,
                    pinId: '',
                    soulbondToken: '',
                    unconfirmed: '',
                    chatpubkey: '',
                })
            }),
            getters: {
                has: (state) => !!state.last,
                isAuthorized: (state) => {
                    const connectedStore = useConnectionStore();
                    return !!(state.last.address && state.last.metaid && connectedStore.last.status === 'connected');
                }
            },
            actions: {
                async updateUserInfo(userInfo) {
                    this.last = { ...this.last, ...userInfo };
                },

                async setUserInfo(address) {
                    if (!address) return this.last;

                    try {
                        const userRes = await manApi.get(`/info/address/${address}`);
                        if (userRes) {
                            this.last = userRes;

                            // Â¶ÇÊûúÊ≤°ÊúâÁî®Êà∑ÂêçÔºåÊòæÁ§∫ÁºñËæëËµÑÊñôÊ®°ÊÄÅÊ°Ü
                            if (!this.last.name) {
                                const layoutStore = useLayoutStore();
                                layoutStore.isShowProfileEditModal = true;
                            }
                        }
                        return this.last;
                    } catch (e) {
                        const { showToast } = useToast();
                        showToast(e.message, 'error');
                        return this.last;
                    }
                },

                clearUserInfo() {
                    this.last = {
                        address: '',
                        avatar: '',
                        avatarId: '',
                        background: '',
                        bio: '',
                        bioId: '',
                        blocked: false,
                        chainName: 'mvc',
                        fdv: 0,
                        followCount: 0,
                        isInit: false,
                        metaid: '',
                        name: '',
                        nameId: '',
                        nftAvatar: '',
                        nftAvatarId: '',
                        number: 0,
                        pdv: 0,
                        pinId: '',
                        soulbondToken: '',
                        unconfirmed: '',
                        chatpubkey: '',
                    };
                }
            }
        });

        // Credentials Store - Âá≠ËØÅÁÆ°ÁêÜ
        const useCredentialsStore = defineStore('credentials', {
            state: () => ({
                credentials: useLocalStorage('credentials', []),
                signing: false
            }),
            getters: {
                getByAddress: (state) => (address) => {
                    return state.credentials.find(s => s.address === address);
                },
                has: (state) => (address) => {
                    return !!state.credentials.find(s => s.address === address);
                },
                get: (state) => {
                    const connectionStore = useConnectionStore();
                    const connected = connectionStore.connected;
                    const address = connectionStore.getAddress;
                    const credential = state.credentials.find(s => s.address === address);
                    const ready = connected && !!credential;
                    return ready ? credential : false;
                },
                ready: (state) => {
                    const connectionStore = useConnectionStore();
                    const connected = connectionStore.connected;
                    const address = connectionStore.getAddress;
                    const credential = state.credentials.find(s => s.address === address);
                    return connected && !!credential;
                }
            },
            actions: {
                add({ publicKey, signature, address }) {
                    if (this.credentials.find(s => s.address === address)) return;
                    this.credentials.push({ publicKey, signature, address });
                },

                remove(address) {
                    this.credentials = this.credentials.filter(s => s.address !== address);
                },

                clear() {
                    this.credentials = [];
                },

                async sign() {
                    const connectionStore = useConnectionStore();
                    const connection = connectionStore.last;

                    if (!connection.address || connection.status === 'disconnected') {
                        throw new Error('Please connect to a wallet first.');
                    }

                    const address = connectionStore.getAddress;
                    const credential = this.getByAddress(address);
                    if (credential) return credential;

                    this.signing = true;

                    const message = CONSTANTS.SIGNING_MESSAGE;
                    let publicKey = connection.pubKey;
                    let signature = '';

                    try {
                        publicKey = await connectionStore.adapter.getMvcPublickey();
                        signature = await connectionStore.adapter.signMessage(message);

                        this.add({ publicKey, signature, address });
                        return { publicKey, signature, address };
                    } catch (e) {
                        this.signing = false;
                        throw e;
                    }
                },

                async login() {
                    const connectionStore = useConnectionStore();
                    const synced = await connectionStore.sync();
                    if (!synced) return false;

                    const credential = await this.sign();
                    if (!credential) return false;

                    const userStore = useUserStore();
                    await userStore.setUserInfo(credential.address);
                    return credential;
                }
            }
        });

        // Chain Store - Ë¥πÁéáÁÆ°ÁêÜ
        const useChainStore = defineStore('chain', {
            state: () => ({
                state: useLocalStorage('chain-fee-rates', {
                    btc: {
                        fastestFee: 1,
                        halfHourFee: 1,
                        hourFee: 1,
                        economyFee: 1,
                        minimumFee: 1,
                        customizeFee: 1,
                        selectedFeeType: 'economyFee',
                        lastUpdated: 0,
                    },
                    mvc: {
                        fastestFee: 1,
                        halfHourFee: 1,
                        hourFee: 1,
                        economyFee: 1,
                        minimumFee: 1,
                        customizeFee: 1,
                        selectedFeeType: 'fastestFee',
                        lastUpdated: 0,
                    },
                    currentChain: 'mvc',
                })
            }),
            actions: {
                async fetchFeeRates(url) {
                    try {
                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return await response.json();
                    } catch (error) {
                        console.error('Failed to fetch fee rates:', error);
                        throw error;
                    }
                },

                async updateBtcFeeRate() {
                    try {
                        const feeRates = await this.fetchFeeRates(CONSTANTS.BTC_FEE_RATE_URL);
                        this.state.btc.fastestFee = feeRates.fastestFee;
                        this.state.btc.halfHourFee = feeRates.halfHourFee;
                        this.state.btc.hourFee = feeRates.hourFee;
                        this.state.btc.economyFee = feeRates.economyFee;
                        this.state.btc.minimumFee = feeRates.minimumFee;
                        this.state.btc.lastUpdated = Date.now();
                    } catch (error) {
                        console.error('Failed to update BTC fee rates:', error);
                    }
                },

                async updateMvcFeeRate() {
                    try {
                        const feeRates = await this.fetchFeeRates(CONSTANTS.MVC_FEE_RATE_URL);
                        this.state.mvc.fastestFee = feeRates.fastestFee;
                        this.state.mvc.halfHourFee = feeRates.halfHourFee;
                        this.state.mvc.hourFee = feeRates.hourFee;
                        this.state.mvc.economyFee = 1;
                        this.state.mvc.minimumFee = feeRates.minimumFee;
                        this.state.mvc.lastUpdated = Date.now();
                    } catch (error) {
                        console.error('Failed to update MVC fee rates:', error);
                    }
                },

                async updateAllFeeRates() {
                    await Promise.allSettled([this.updateBtcFeeRate(), this.updateMvcFeeRate()]);
                },

                setBtcCustomizeFee(feeRate) {
                    this.state.btc.customizeFee = feeRate;
                    this.state.btc.lastUpdated = Date.now();
                },

                setMvcCustomizeFee(feeRate) {
                    this.state.mvc.customizeFee = feeRate;
                    this.state.mvc.lastUpdated = Date.now();
                },

                setBtcFeeType(feeType) {
                    this.state.btc.selectedFeeType = feeType;
                },

                setMvcFeeType(feeType) {
                    this.state.mvc.selectedFeeType = feeType;
                },

                setCurrentChain(chain) {
                    this.state.currentChain = chain;
                },

                btcFeeRate() {
                    return this.state.btc[this.state.btc.selectedFeeType];
                },

                mvcFeeRate() {
                    return this.state.mvc[this.state.mvc.selectedFeeType];
                }
            }
        });

        // Approved Store - ÊîØ‰ªòÊéàÊùÉÁÆ°ÁêÜ
        const useApprovedStore = defineStore('approved', {
            state: () => ({
                last: useLocalStorage('last-approved', {
                    isEnabled: true,
                    isApproved: false,
                    autoPaymentAmount: 10000,
                })
            }),
            getters: {
                has: (state) => !!state.last,
                canUse: (state) => state.last.isEnabled && state.last.isApproved,
                canApproved: (state) => state.last.isEnabled === true && state.last.isApproved === false
            },
            actions: {
                async getPaymentStatus() {
                    const connectionStore = useConnectionStore();
                    const res = await connectionStore.adapter.autoPaymentStatus();
                    this.last = res;
                },

                async getAutoPayment() {
                    if (this.canApproved) {
                        const connectionStore = useConnectionStore();
                        const res = await connectionStore.adapter.autoPayment();
                        if (res.message === "Auto payment approved") {
                            this.last.isApproved = true;
                        }
                    }
                },

                clear() {
                    if (!this.last) return;
                    this.last.isEnabled = true;
                    this.last.isApproved = false;
                    this.last.autoPaymentAmount = 10000;
                }
            }
        });

        // Connection Store - Èí±ÂåÖËøûÊé•ÁÆ°ÁêÜ
        const useConnectionStore = defineStore('connection', {
            state: () => ({
                last: useLocalStorage('last-connection', {
                    wallet: 'metalet',
                    status: 'disconnected',
                    address: '',
                    pubKey: '',
                })
            }),
            getters: {
                has: (state) => !!state.last,
                connected: (state) => state.last.status === 'connected' && !!state.last.address,
                getAddress: (state) => state.last.address,
                isTaproot: (state) => state.last.address.startsWith('bc1p') || state.last.address.startsWith('tb1p'),
                getPubKey: (state) => state.last.pubKey,
                provider: (state) => {
                    if (!state.last) return null;
                    return window.metaidwallet;
                },
                adapter: (state) => {
                    if (!state.last) throw new Error('No connection');
                    return getWalletAdapter(state.last.wallet);
                }
            },
            actions: {
                async connect(wallet) {
                    const connection = this.last ? JSON.parse(JSON.stringify(this.last)) : {
                        wallet,
                        status: 'disconnected',
                        address: '',
                        pubKey: '',
                    };

                    try {
                        let connectRes = await getWalletAdapter(wallet).connect();

                        if (connectRes) {
                            const networkStore = useNetworkStore();
                            const appNetwork = networkStore.network;

                            // Ê£ÄÊü•Âπ∂ÂàáÊç¢ÁΩëÁªú
                            const metaNetwork = await getWalletAdapter('metalet').getNetwork();
                            if (metaNetwork !== appNetwork) {
                                await getWalletAdapter('metalet').switchNetwork(appNetwork);
                                connectRes = await getWalletAdapter('metalet').connect();
                            }

                            connection.address = connectRes.address;
                            connection.pubKey = connectRes.pubKey;
                            connection.status = 'connected';
                            connection.wallet = wallet;

                            this.last = connection;
                            return this.last;
                        }
                    } catch (e) {
                        const { showToast } = useToast();
                        showToast(e.message, 'error');
                        connection.status = 'disconnected';
                        connection.wallet = wallet;
                        this.last = connection;
                    }

                    return this.last;
                },

                async sync() {
                    if (!this.connected) return;

                    this.last.status = 'connected';
                    this.last.address = await this.adapter.getAddress();
                    this.last.pubKey = await this.adapter.getMvcPublickey();

                    const networkStore = useNetworkStore();
                    const appNetwork = networkStore.network;
                    let networkSynced = true;

                    const network = await this.adapter.getNetwork();
                    if (network !== appNetwork) {
                        networkSynced = false;
                        this.disconnect();
                    } else {
                        const userStore = useUserStore();
                        await userStore.setUserInfo(this.last.address);
                    }

                    if (networkSynced) {
                        return this.last;
                    }
                },

                async disconnect() {
                    if (!this.last) return;

                    this.last.status = 'disconnected';
                    this.last.address = '';
                    this.last.pubKey = '';
                    this.last.wallet = 'metalet';

                    const userStore = useUserStore();
                    const approvedStore = useApprovedStore();
                    const credentialsStore = useCredentialsStore();

                    await userStore.clearUserInfo();
                    credentialsStore.clear();

                    if (window.metaidwallet?.smallPay) {
                        await approvedStore.clear();
                    }
                }
            }
        });

        // ==================== Metalet Èí±ÂåÖÈÄÇÈÖçÂô® ====================
        // Ê£ÄÊü•MetaletÈí±ÂåÖ
        function checkMetalet() {
            const connectionStore = useConnectionStore();
            if (!window.metaidwallet && !connectionStore.connected) {
                throw new Error('Please install the Metalet wallet extension first.');
            }
        }

        // Ê£ÄÊü•MetaletÁä∂ÊÄÅ
        function checkMetaletStatus(res, actionName) {
            if (res?.status) {
                throw new Error(`Metalet ${actionName} status: ${res?.status}`);
            }
            return res;
        }

        // MetaletÈÄÇÈÖçÂô®ÂØπË±°
        const getWalletAdapter = (wallet) => {
            if (wallet !== 'metalet') {
                throw new Error(`Unsupported wallet: ${wallet}`);
            }

            return {
                async connect() {
                    checkMetalet();
                    const connectRes = await window.metaidwallet.connect();
                    return checkMetaletStatus(connectRes, 'connect');
                },

                async getMvcAddress() {
                    checkMetalet();
                    const addressRes = await window.metaidwallet.getAddress();
                    return checkMetaletStatus(addressRes, 'get address');
                },

                async getBtcAddress() {
                    checkMetalet();
                    const addressRes = await window.metaidwallet.btc.getAddress();
                    return checkMetaletStatus(addressRes, 'get btc address');
                },

                async getMvcBalance() {
                    checkMetalet();
                    return await window.metaidwallet.getMvcBalance();
                },

                async signMvcMessage(message) {
                    checkMetalet();
                    const { signature } = await window.metaidwallet.signMessage({ message });
                    const buf = Buffer.from(signature.signature, 'hex');
                    return buf.toString('base64');
                },

                async getMvcPublickey() {
                    checkMetalet();
                    const MvcPubkey = await window.metaidwallet.getPublicKey();
                    return checkMetaletStatus(MvcPubkey, 'get mvc publickey');
                },

                async getAddress() {
                    checkMetalet();
                    const addressRes = await window.metaidwallet.getAddress();
                    return checkMetaletStatus(addressRes, 'get address');
                },

                async getNetwork() {
                    checkMetalet();
                    return await window.metaidwallet.getNetwork().then(({ network }) => {
                        if (network === 'mainnet') {
                            return 'livenet';
                        }
                        return 'testnet';
                    });
                },

                async switchNetwork(network) {
                    checkMetalet();
                    return await window.metaidwallet.switchNetwork(network === 'livenet' ? 'mainnet' : 'testnet').then((res) => {
                        if (res.status === 'canceled') {
                            throw new Error('Switch network canceled');
                        }
                        if (res.network === 'mainnet') {
                            return 'livenet';
                        }
                        return 'testnet';
                    });
                },

                async disconnect() {},

                async signMessage(message) {
                    checkMetalet();
                    const messageBase64 = await window.metaidwallet.btc.signMessage(message);
                    return checkMetaletStatus(messageBase64, 'get signature');
                },

                async autoPaymentStatus() {
                    checkMetalet();
                    return await window.metaidwallet.autoPaymentStatus();
                },

                async autoPayment() {
                    checkMetalet();
                    return await window.metaidwallet.autoPayment();
                }
            };
        };

        // ==================== Connection Modal State ====================
        const useConnectionModal = createGlobalState(() => {
            const isConnectionModalOpen = ref(false);
            const isWalletMissingModalOpen = ref(false);
            const missingWallet = ref();

            const openConnectionModal = () => {
                isConnectionModalOpen.value = true;
            };

            const closeConnectionModal = () => {
                isConnectionModalOpen.value = false;
            };

            const openWalletMissingModal = () => {
                isWalletMissingModalOpen.value = true;
            };

            const closeWalletMissingModal = () => {
                isWalletMissingModalOpen.value = false;
            };

            const setMissingWallet = (wallet) => {
                missingWallet.value = wallet;
                openWalletMissingModal();
            };

            return {
                isConnectionModalOpen,
                openConnectionModal,
                closeConnectionModal,
                isWalletMissingModalOpen,
                openWalletMissingModal,
                closeWalletMissingModal,
                missingWallet,
                setMissingWallet,
            };
        });

        // ==================== Vue ÁªÑ‰ª∂ÂÆö‰πâ ====================

        // Toast/Alert ÁªÑ‰ª∂
        const ToastContainer = {
            template: `
                <div class="toast toast-top toast-end z-[10000]">
                    <div v-for="alert in alerts" :key="alert.id"
                         :class="['alert', alertClass(alert.type)]"
                         class="shadow-lg">
                        <span>{{ alert.message }}</span>
                    </div>
                </div>
            `,
            setup() {
                const { alerts } = useToast();

                const alertClass = (type) => {
                    const classes = {
                        'success': 'alert-success',
                        'error': 'alert-error',
                        'warning': 'alert-warning',
                        'info': 'alert-info',
                    };
                    return classes[type] || 'alert-info';
                };

                return { alerts, alertClass };
            }
        };

        // ËøûÊé•Èí±ÂåÖÊ®°ÊÄÅÊ°ÜÁªÑ‰ª∂
        const ConnectWalletModal = {
            template: `
                <div v-if="isConnectionModalOpen" class="modal modal-open">
                    <div class="modal-box relative">
                        <button v-if="!loading"
                                class="btn btn-sm btn-circle absolute right-2 top-2"
                                @click="closeConnectionModal">
                            ‚úï
                        </button>

                        <h3 class="font-bold text-lg mb-4">ËøûÊé•Èí±ÂåÖ</h3>

                        <div class="space-y-3">
                            <button class="btn btn-outline w-full justify-start gap-3"
                                    @click="connectMetalet"
                                    :disabled="loading">
                                <div class="w-10 h-10 flex items-center justify-center">
                                    <span class="text-2xl">üîê</span>
                                </div>
                                <div class="text-left flex-1">
                                    <div class="font-semibold">Metalet</div>
                                    <span class="text-sm text-gray-500">Connect to Metalet Wallet</span>
                                </div>
                            </button>
                        </div>
                    </div>
                </div>
            `,
            setup() {
                const { isConnectionModalOpen, closeConnectionModal, setMissingWallet } = useConnectionModal();
                const connectionStore = useConnectionStore();
                const credentialsStore = useCredentialsStore();
                const rootStore = useRootStore();
                const { showToast } = useToast();
                const loading = ref(false);

                const connectMetalet = async () => {
                    if (!window.metaidwallet) {
                        setMissingWallet('metalet');
                        return;
                    }

                    try {
                        loading.value = true;
                        const connection = await connectionStore.connect('metalet');

                        if (connection?.status === 'connected') {
                            await credentialsStore.login();
                            await sleep(300);
                            closeConnectionModal();
                        }

                        // Ê£ÄÊü•BTCÂíåMVCÂú∞ÂùÄÊòØÂê¶‰∏ÄËá¥
                        rootStore.checkBtcAddressSameAsMvc()
                            .catch(() => {
                                showToast('BTC Âú∞ÂùÄ‰∏é MVC Âú∞ÂùÄ‰∏ç‰∏ÄËá¥', 'warning');
                            });
                    } catch (err) {
                        showToast(err.message, 'error');
                    } finally {
                        loading.value = false;
                    }
                };

                return {
                    isConnectionModalOpen,
                    closeConnectionModal,
                    connectMetalet,
                    loading
                };
            }
        };

        // Áî®Êà∑Â§¥ÂÉèÁªÑ‰ª∂
        const UserAvatar = {
            props: {
                image: String,
                metaId: String,
                name: String
            },
            template: `
                <div class="p-[1px] rounded-full ">
                    <div class="rounded-full ">
                        <img :src="avatarSrc" :alt="name || 'User'" class="user-avatar " />
                    </div>
                </div>
            `,
            setup(props) {
                const avatarSrc = computed(() => {
                    if (props.image) {
                        return `https://man.metaid.io${props.image}`;
                    }
                    // ÈªòËÆ§Â§¥ÂÉè
                    return 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"%3E%3Cpath d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/%3E%3C/svg%3E';
                });

                return { avatarSrc };
            }
        };

        // ProfileEditModal - Áî®Êà∑ËµÑÊñôÁºñËæëÊ®°ÊÄÅÊ°ÜÁªÑ‰ª∂
        const ProfileEditModal = {
            props: {
                modelValue: Boolean
            },
            emits: ['update:modelValue'],
            template: `
                <div v-if="modelValue" class="modal modal-open">
                    <div class="modal-box w-full max-w-[500px] relative">
                        <!-- ÂÖ≥Èó≠ÊåâÈíÆ -->
                        <button
                            class="btn btn-sm btn-circle absolute bottom-0 left-1/2 transform -translate-x-1/2 translate-y-14 bg-base-200 hover:bg-base-300"
                            @click="closeModal">
                            ‚úï
                        </button>

                        <h3 class="font-bold text-2xl text-center mb-2">Set Up Your Profile</h3>
                        <p class="text-center text-base-content/60 mb-6">
                            Make your account stand out ‚Äî add a unique avatar and display name!
                        </p>

                        <!-- Â§¥ÂÉè‰∏ä‰º†Âå∫Âüü -->
                        <div class="flex justify-center mb-6">
                            <div class="relative">
                                <input
                                    ref="fileInput"
                                    type="file"
                                    @change="handleFileChange"
                                    accept="image/jpeg,image/png"
                                    class="hidden"
                                    id="avatar-upload"
                                />
                                <label for="avatar-upload" class="cursor-pointer">
                                    <img
                                        :src="imageUrl || currentAvatar"
                                        alt="Avatar Preview"
                                        class="w-28 h-28 rounded-[33%] object-cover border-2 border-black"
                                    />
                                </label>
                                <!-- Áõ∏Êú∫ÂõæÊ†áÊåâÈíÆ -->
                                <button
                                    type="button"
                                    @click="triggerFileInput"
                                    class="absolute bottom-4 right-0 w-6 h-6 rounded-full bg-primary hover:bg-primary-focus text-primary-content flex items-center justify-center transition-colors shadow-lg">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <!-- Áî®Êà∑ÂêçËæìÂÖ• -->
                        <div class="form-control mb-4">
                            <label class="label">
                                <span class="label-text font-medium">User Name</span>
                            </label>
                            <input
                                v-model="username"
                                type="text"
                                placeholder="What's Your MetaWeb User Name?"
                                class="input input-bordered w-full"
                            />
                        </div>

                        <!-- ‰∏™‰∫∫ÁÆÄ‰ªãËæìÂÖ• -->
                        <div class="form-control mb-6">
                            <label class="label">
                                <span class="label-text font-medium">Profile</span>
                            </label>
                            <input
                                v-model="profile"
                                type="text"
                                placeholder="Profile (Optional)"
                                class="input input-bordered w-full"
                            />
                        </div>

                        <!-- Êèê‰∫§ÊåâÈíÆ -->
                        <div class="flex justify-end">
                            <button
                                type="button"
                                @click="save"
                                :disabled="!hasChanges || loading"
                                :class="['btn btn-circle', hasChanges && !loading ? 'btn-primary' : 'btn-disabled']">
                                <svg v-if="!loading" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                                </svg>
                                <span v-else class="loading loading-spinner"></span>
                            </button>
                        </div>
                    </div>
                </div>
            `,
            setup(props, { emit }) {
                const userStore = useUserStore();
                const { showToast } = useToast();

                const fileInput = ref(null);
                const username = ref('');
                const profile = ref('');
                const imageUrl = ref('');
                const currentAvatar = ref('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"%3E%3Cpath d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/%3E%3C/svg%3E');
                const imgRaw = ref(null);
                const loading = ref(false);

                // ÁõëÂê¨Áî®Êà∑Â§¥ÂÉèÂèòÂåñ
                watch(
                    () => userStore.last?.avatar,
                    (newAvatar) => {
                        if (newAvatar && newAvatar.startsWith('http')) {
                            currentAvatar.value = newAvatar;
                        }
                    },
                    { immediate: true }
                );

                // ÁõëÂê¨Ê®°ÊÄÅÊ°ÜÊâìÂºÄ/ÂÖ≥Èó≠
                watch(
                    () => props.modelValue,
                    (newVal) => {
                        if (newVal) {
                            // Ê®°ÊÄÅÊ°ÜÊâìÂºÄÊó∂ÂàùÂßãÂåñË°®ÂçïÊï∞ÊçÆ
                            username.value = userStore.last?.name || '';
                            profile.value = userStore.last?.bio || '';
                            imageUrl.value = '';
                            imgRaw.value = null;
                        }
                    }
                );

                // ËÆ°ÁÆóÊòØÂê¶ÊúâÂèòÊõ¥
                const hasChanges = computed(() => {
                    return (
                        imageUrl.value ||
                        username.value !== (userStore.last?.name || '') ||
                        profile.value !== (userStore.last?.bio || '')
                    );
                });

                // Ëß¶ÂèëÊñá‰ª∂ÈÄâÊã©
                const triggerFileInput = () => {
                    fileInput.value?.click();
                };

                // Â§ÑÁêÜÊñá‰ª∂ÈÄâÊã©
                const handleFileChange = async (event) => {
                    const target = event.target;
                    const file = target.files?.[0];

                    if (!file) return;

                    // È™åËØÅÊñá‰ª∂Á±ªÂûã
                    if (file.type !== 'image/jpeg' && file.type !== 'image/png') {
                        showToast('Avatar picture must be JPG or PNG format!', 'error');
                        return;
                    }

                    try {
                        // ÊòæÁ§∫È¢ÑËßà
                        const reader = new FileReader();
                        reader.addEventListener('load', () => {
                            imageUrl.value = reader.result;
                        });
                        reader.readAsDataURL(file);
                        imgRaw.value = file;
                    } catch (error) {
                        console.error('Failed to process image:', error);
                        showToast('Failed to process image. Please try another image.', 'error');
                    }
                };

                // ‰øùÂ≠ò
                const save = async () => {
                    if (!hasChanges.value || loading.value) {
                        showToast('No changes to save.', 'info');
                        return;
                    }

                    loading.value = true;
                    try {
                        const values = {};

                        // Â§ÑÁêÜÂ§¥ÂÉè
                        if (imgRaw.value) {
                            const fileList = [imgRaw.value];
                            const [image] = await image2Attach(fileList);
                            values.avatar = Buffer.from(image.data, 'hex').toString('base64');
                        }

                        // Â§ÑÁêÜÁî®Êà∑Âêç
                        if (username.value !== userStore.last?.name) {
                            values.name = username.value;
                        }

                        // Â§ÑÁêÜ‰∏™‰∫∫ÁÆÄ‰ªã
                        if (profile.value !== userStore.last?.bio) {
                            values.bio = profile.value;
                        }

                        // Ëé∑Âèñ ECDH ÂÖ¨Èí•ÔºàÂ¶ÇÊûúÊ≤°ÊúâÔºâ
                        if (!userStore.last?.chatpubkey) {
                            const ecdh = await getEcdhPublickey();
                            if (ecdh) {
                                values.chatpubkey = ecdh.ecdhPubKey;
                            }
                        }

                        // Ë∞ÉÁî®ÂàõÂª∫ÊàñÊõ¥Êñ∞Áî®Êà∑‰ø°ÊÅØ
                        await createOrUpdateUserInfo({
                            userData: values,
                            oldUserData: {
                                nameId: userStore.last?.nameId || '',
                                bioId: userStore.last?.bioId || '',
                                avatarId: userStore.last?.avatarId || '',
                                chatpubkey: userStore.last?.chatpubkey || '',
                            },
                            options: {
                                feeRate: 1,
                                network: 'livenet',
                                assistDomain: 'https://www.metaso.network/assist-open-api',
                            },
                        });

                        // Â¶ÇÊûúÊòØÈ¶ñÊ¨°ËÆæÁΩÆÔºåËé∑Âèñ MVC Â•ñÂä±
                        if (!userStore.last.nameId) {
                            const publicKey = await window.metaidwallet.btc.getPublicKey();
                            const signature = await window.metaidwallet.btc.signMessage('metaso.network');
                            await getMVCRewards(
                                {
                                    address: userStore.last.address,
                                    gasChain: 'mvc',
                                },
                                {
                                    'X-Public-Key': publicKey,
                                    'X-Signature': signature,
                                }
                            );
                        }

                        // Êõ¥Êñ∞Áî®Êà∑‰ø°ÊÅØ
                        await userStore.setUserInfo(userStore.last.address);
                        showToast('Profile updated successfully!', 'success');
                        emit('update:modelValue', false);
                    } catch (error) {
                        console.error('Failed to save profile changes:', error);
                        showToast('Failed to save profile changes.', 'error');
                    } finally {
                        loading.value = false;
                    }
                };

                const closeModal = () => {
                    if (!loading.value) {
                        emit('update:modelValue', false);
                    }
                };

                return {
                    fileInput,
                    username,
                    profile,
                    imageUrl,
                    currentAvatar,
                    loading,
                    hasChanges,
                    triggerFileInput,
                    handleFileChange,
                    save,
                    closeModal,
                };
            }
        };

        // Ë¥πÁéáÊ®°ÊÄÅÊ°ÜÁªÑ‰ª∂
        const FeeModal = {
            props: {
                modelValue: Boolean
            },
            emits: ['update:modelValue', 'confirm'],
            template: `
                <div v-if="modelValue" class="modal modal-open">
                    <div class="modal-box w-full max-w-2xl">
                        <h3 class="font-bold text-lg mb-4">Fee Settings</h3>

                        <!-- BTC Section -->
                        <div class="mb-6">
                            <div class="flex items-center gap-2 mb-3 cursor-pointer" @click="selectChain('btc')">
                                <span class="text-2xl">‚Çø</span>
                                <div>
                                    <div class="font-semibold">BTC Network</div>
                                </div>
                            </div>

                            <div class="grid grid-cols-3 gap-3">
                                <button :class="['btn', selectedChain === 'btc' && selectedBTCFeeType === 'economyFee' ? 'btn-primary' : 'btn-outline']"
                                        @click="selectFeeType('economyFee', 'btc')">
                                    <div class="text-center">
                                        <div class="font-semibold">ECO</div>
                                        <div class="text-sm">{{ chainStore.state.btc.economyFee }} sat/vB</div>
                                    </div>
                                </button>

                                <button :class="['btn', selectedChain === 'btc' && selectedBTCFeeType === 'halfHourFee' ? 'btn-primary' : 'btn-outline']"
                                        @click="selectFeeType('halfHourFee', 'btc')">
                                    <div class="text-center">
                                        <div class="font-semibold">Normal</div>
                                        <div class="text-sm">{{ chainStore.state.btc.halfHourFee }} sat/vB</div>
                                    </div>
                                </button>

                                <button :class="['btn', selectedChain === 'btc' && selectedBTCFeeType === 'customizeFee' ? 'btn-primary' : 'btn-outline']"
                                        @click="selectFeeType('customizeFee', 'btc')">
                                    <div class="text-center">
                                        <div class="font-semibold">Custom</div>
                                        <input v-if="selectedChain === 'btc' && selectedBTCFeeType === 'customizeFee'"
                                               v-model="customBTCValue"
                                               type="number"
                                               class="input input-sm w-16 text-center"
                                               @click.stop
                                               :min="1" />
                                        <div v-else class="text-sm">{{ chainStore.state.btc.customizeFee }} sat/vB</div>
                                    </div>
                                </button>
                            </div>
                        </div>

                        <!-- MVC Section -->
                        <div class="mb-6">
                            <div class="flex items-center gap-2 mb-3 cursor-pointer" @click="selectChain('mvc')">
                                <span class="text-2xl">‚ìÇ</span>
                                <div>
                                    <div class="font-semibold">MVC Network</div>
                                    <span class="badge badge-warning badge-sm">Bitcoin sidechain</span>
                                </div>
                            </div>

                            <div class="grid grid-cols-3 gap-3">
                                <button :class="['btn', selectedChain === 'mvc' && selectedMVCFeeType === 'economyFee' ? 'btn-primary' : 'btn-outline']"
                                        @click="selectFeeType('economyFee', 'mvc')">
                                    <div class="text-center">
                                        <div class="font-semibold">ECO</div>
                                        <div class="text-sm">{{ chainStore.state.mvc.economyFee }} sat/vB</div>
                                    </div>
                                </button>

                                <button :class="['btn', selectedChain === 'mvc' && selectedMVCFeeType === 'fastestFee' ? 'btn-primary' : 'btn-outline']"
                                        @click="selectFeeType('fastestFee', 'mvc')">
                                    <div class="text-center">
                                        <div class="font-semibold">High</div>
                                        <div class="text-sm">{{ chainStore.state.mvc.fastestFee }} sat/vB</div>
                                    </div>
                                </button>

                                <button :class="['btn', selectedChain === 'mvc' && selectedMVCFeeType === 'customizeFee' ? 'btn-primary' : 'btn-outline']"
                                        @click="selectFeeType('customizeFee', 'mvc')">
                                    <div class="text-center">
                                        <div class="font-semibold">Custom</div>
                                        <input v-if="selectedChain === 'mvc' && selectedMVCFeeType === 'customizeFee'"
                                               v-model="customMVCValue"
                                               type="number"
                                               class="input input-sm w-16 text-center"
                                               @click.stop />
                                        <div v-else class="text-sm">{{ chainStore.state.mvc.customizeFee }} sat/vB</div>
                                    </div>
                                </button>
                            </div>
                        </div>

                        <div class="modal-action">
                            <button class="btn" @click="$emit('update:modelValue', false)">Cancel</button>
                            <button class="btn btn-primary" @click="handleConfirm">OK</button>
                        </div>
                    </div>
                </div>
            `,
            setup(props, { emit }) {
                const chainStore = useChainStore();
                const { showToast } = useToast();

                const selectedChain = ref('btc');
                const selectedBTCFeeType = ref(chainStore.state.btc.selectedFeeType);
                const selectedMVCFeeType = ref(chainStore.state.mvc.selectedFeeType);
                const customBTCValue = ref(chainStore.state.btc.customizeFee);
                const customMVCValue = ref(chainStore.state.mvc.customizeFee);

                const selectChain = (chain) => {
                    selectedChain.value = chain;
                };

                const selectFeeType = (feeType, chain) => {
                    selectedChain.value = chain;
                    if (chain === 'btc') {
                        selectedBTCFeeType.value = feeType;
                    } else {
                        selectedMVCFeeType.value = feeType;
                    }
                };

                const handleConfirm = () => {
                    chainStore.setCurrentChain(selectedChain.value);

                    if (selectedChain.value === 'btc') {
                        chainStore.setBtcFeeType(selectedBTCFeeType.value);
                        if (selectedBTCFeeType.value === 'customizeFee') {
                            if (customBTCValue.value < 1) {
                                showToast('BTC custom fee must be at least 1 sat/vB', 'error');
                                customBTCValue.value = 1;
                            }
                            chainStore.setBtcCustomizeFee(customBTCValue.value);
                        }
                    } else {
                        chainStore.setMvcFeeType(selectedMVCFeeType.value);
                        if (selectedMVCFeeType.value === 'customizeFee') {
                            chainStore.setMvcCustomizeFee(customMVCValue.value);
                        }
                    }

                    emit('update:modelValue', false);
                };

                watch(() => props.modelValue, (newValue) => {
                    if (newValue) {
                        selectedChain.value = chainStore.state.currentChain;
                        if (selectedChain.value === 'btc') {
                            selectedBTCFeeType.value = chainStore.state.btc.selectedFeeType;
                            customBTCValue.value = chainStore.state.btc.customizeFee;
                        } else {
                            selectedMVCFeeType.value = chainStore.state.mvc.selectedFeeType;
                            customMVCValue.value = chainStore.state.mvc.customizeFee;
                        }
                    }
                }, { immediate: true });

                return {
                    chainStore,
                    selectedChain,
                    selectedBTCFeeType,
                    selectedMVCFeeType,
                    customBTCValue,
                    customMVCValue,
                    selectChain,
                    selectFeeType,
                    handleConfirm
                };
            }
        };

        // Áî®Êà∑Êìç‰ΩúÁªÑ‰ª∂
        const LoginUserOperate = {
            components: {
                UserAvatar,
                FeeModal
            },
            template: `
                <div class="flex items-center gap-3">
                    <!-- ËøûÊé•Èí±ÂåÖÊåâÈíÆ -->
                    <button v-if="!connectionStore.connected"
                            class="btn btn-primary rounded-lg btn-base"
                            @click="openConnectionModal">
                        <span class="text-base text-white">Connect Wallet</span>
                    </button>

                    <!-- ÊéàÊùÉÊåâÈíÆ -->
                    <button v-else-if="!credentialsStore.get"
                            class="btn btn-primary rounded-lg btn-base"
                            @click="credentialsStore.login()">
                          <span class="text-base text-white">Authorize</span>
                    </button>

                    <!-- Áî®Êà∑‰ø°ÊÅØ -->
                    <template v-else-if="userStore.isAuthorized">
                        <UserAvatar
                            :image="userStore.last.avatar"
                            :meta-id="userStore.last.metaid"
                            :name="userStore.last.name" class="w-10 h-10 cursor-pointer" />
                            
                        <!-- Áî®Êà∑Âêç -->
                        <span class="font-medium">{{ userStore.last.name || userStore.last.metaid.slice(0,6) }}</span>
                    </template>

                    <!-- Êõ¥Â§öÊìç‰ΩúËèúÂçï -->
                    <div class="dropdown dropdown-end" v-if="userStore.isAuthorized">
                        <label tabindex="0" class="btn btn-circle btn-ghost border  border-base-300">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="w-5 h-5 stroke-current">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"></path>
                            </svg>
                        </label>
                        <ul tabindex="0" class="dropdown-content menu p-2 shadow bg-base-100 rounded-box w-64 mt-3 z-[9999]">
                            <!-- My Notes -->
                            <li>
                                <a @click="router.push('/mynote')">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                    </svg>
                                    ÊàëÁöÑÁ¨îËÆ∞
                                </a>
                            </li>

                            <!-- Draft Box -->
                            <li>
                                <a @click="router.push('/draft')">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                                    </svg>
                                    ËçâÁ®øÁÆ±
                                </a>
                            </li>

                            <div class="divider my-0"></div>

                            <!-- Fee Settings -->
                            <li>
                                <a @click="handleFeeClick" class="flex items-center justify-between">
                                    <div class="flex items-center gap-2">
                                        <span>{{ chainStore.state.currentChain.toUpperCase() }}</span>
                                        <span class="font-medium">{{ currentFeeRate }}</span>
                                        <span class="text-sm text-gray-500">
                                            {{ chainStore.state.currentChain === 'btc' ? 'sat/vB' : 'sats/b' }}
                                        </span>
                                    </div>
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                                    </svg>
                                </a>
                            </li>

                            <div class="divider my-0"></div>

                            <!-- Logout -->
                            <li>
                                <a @click="connectionStore.disconnect()" class="text-error">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                                    </svg>
                                    Logout
                                </a>
                            </li>
                        </ul>
                    </div>

                    <!-- Fee Modal -->
                    <FeeModal v-model="showFeeModal" @confirm="handleFeeConfirm" />
                </div>
            `,
            setup() {
                const { openConnectionModal } = useConnectionModal();
                const connectionStore = useConnectionStore();
                const credentialsStore = useCredentialsStore();
                const userStore = useUserStore();
                const chainStore = useChainStore();

                const showFeeModal = ref(false);

                const currentFeeRate = computed(() => {
                    const currentChain = chainStore.state.currentChain;
                    const chainData = chainStore.state[currentChain];
                    const selectedFeeType = chainData.selectedFeeType;
                    return chainData[selectedFeeType];
                });

                const handleFeeClick = () => {
                    showFeeModal.value = true;
                };

                const handleFeeConfirm = (data) => {
                    console.log('Fee configuration updated:', data);
                };

                return {
                    openConnectionModal,
                    connectionStore,
                    credentialsStore,
                    userStore,
                    chainStore,
                    showFeeModal,
                    currentFeeRate,
                    handleFeeClick,
                    handleFeeConfirm,
                    router
                };
            }
        };

        // AttachmentPreview - ÈôÑ‰ª∂È¢ÑËßàÁªÑ‰ª∂
        const AttachmentPreview = {
            props: {
                attachments: {
                    type: Array,
                    default: () => []
                }
            },
            emits: ['delete', 'preview'],
            template: `
                <div v-if="attachments.length > 0" class="attachment-preview mb-6">
                    <div class="preview-header">
                        <label class="preview-label text-sm font-medium text-gray-600">ÈôÑ‰ª∂È¢ÑËßà ({{ attachments.length }})</label>
                    </div>
                    <div class="preview-list grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-3">
                        <div
                            v-for="attachment in attachments"
                            :key="attachment.id"
                            class="preview-item relative bg-white border border-gray-200 rounded-lg overflow-hidden hover:shadow-lg transition-all"
                        >
                            <!-- Image Preview -->
                            <div
                                v-if="getFileType(attachment.type) === 'image'"
                                class="preview-content preview-image cursor-pointer"
                                @click="$emit('preview', attachment)"
                            >
                                <img
                                    :src="attachment.blobUrl"
                                    :alt="attachment.name"
                                    class="w-full h-32 object-cover"
                                />
                            </div>

                            <!-- Video Preview -->
                            <div
                                v-else-if="getFileType(attachment.type) === 'video'"
                                class="preview-content preview-video"
                            >
                                <video
                                    :src="attachment.blobUrl"
                                    controls
                                    preload="metadata"
                                    class="w-full h-32 object-contain bg-black"
                                ></video>
                            </div>

                            <!-- Audio Preview -->
                            <div
                                v-else-if="getFileType(attachment.type) === 'audio'"
                                class="preview-content preview-audio flex flex-col items-center justify-center p-4 h-32"
                            >
                                <svg class="w-12 h-12 text-blue-500 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"/>
                                </svg>
                                <audio :src="attachment.blobUrl" controls class="w-full"></audio>
                            </div>

                            <!-- Document Preview -->
                            <div
                                v-else
                                class="preview-content preview-document flex flex-col items-center justify-center p-4 h-32 cursor-pointer hover:text-blue-500 transition-colors"
                                @click="$emit('preview', attachment)"
                            >
                                <svg class="w-16 h-16 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"/>
                                </svg>
                                <span class="text-xs font-semibold">{{ getFileExtension(attachment.name) }}</span>
                            </div>

                            <div class="preview-info p-2">
                                <span class="file-name text-xs text-gray-700 truncate block" :title="attachment.name">{{ attachment.name }}</span>
                                <span class="file-size text-xs text-gray-500">{{ formatFileSize(attachment.file.size) }}</span>
                            </div>
                            <button
                                @click="handleDelete(attachment.id)"
                                class="delete-btn absolute top-2 right-2 p-1.5 bg-red-500 text-white rounded opacity-0 hover:opacity-100 transition-opacity z-10"
                                title="Âà†Èô§ÈôÑ‰ª∂"
                            >
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            `,
            setup(props, { emit }) {
                // Ëé∑ÂèñÊñá‰ª∂Á±ªÂûã
                const getFileType = (mimeType) => {
                    if (mimeType.startsWith('image/')) return 'image';
                    if (mimeType.startsWith('video/')) return 'video';
                    if (mimeType.startsWith('audio/')) return 'audio';
                    if (mimeType === 'application/pdf') return 'pdf';
                    return 'document';
                };

                // Ëé∑ÂèñÊñá‰ª∂Êâ©Â±ïÂêç
                const getFileExtension = (fileName) => {
                    const parts = fileName.split('.');
                    if (parts.length > 1) {
                        return parts[parts.length - 1].toUpperCase();
                    }
                    return 'FILE';
                };

                // Ê†ºÂºèÂåñÊñá‰ª∂Â§ßÂ∞è
                const formatFileSize = (bytes) => {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
                };

                // Âà†Èô§ÈôÑ‰ª∂
                const handleDelete = (id) => {
                    if (id !== undefined && confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ÈôÑ‰ª∂ÂêóÔºü')) {
                        emit('delete', id);
                    }
                };

                return {
                    getFileType,
                    getFileExtension,
                    formatFileSize,
                    handleDelete
                };
            }
        };

        // NoteList - Á¨îËÆ∞ÂàóË°®ÁªÑ‰ª∂
        const NoteList = {
            components: {
                LoginUserOperate,
                UserAvatar
            },
            template: `
                <div class="min-h-screen bg-base-200 pb-20">
                    <!-- Â§¥ÈÉ® -->
                    <div class="bg-base-100 shadow-sm">
                        <div class="container mx-auto px-4 py-4">
                            <div class="flex items-center justify-between">
                                <div class="flex items-center gap-4">
                                
                                 
                                </div>
                                <div class="flex items-center gap-4">
                                    <button v-if="isAuthorized"
                                            @click="goToCreate"
                                            class="btn btn-primary rounded-lg btn-base gap-2">
                                     
                                        <span class="text-base text-white">Write</span>
                                    </button>
                                   
                                    <LoginUserOperate />
                                </div>
                            </div>
                        </div>
                    </div>

                   

                    <!-- Á¨îËÆ∞ÂàóË°® -->
                    <div class="container mx-auto px-4 py-6">
                           <div class="title-section flex flex-col items-center mb-8 mt-10">
                                <h1 class="main-title text-2xl sm:text-3xl md:text-4xl  font-bold text-center">IDNote: Making Your Story Timeless</h1>
                                <p class="subtitle mt-2 text-base sm:text-lg md:text-xl  text-center">Post and Share Your Story On-chain</p>
                                </div>
                        <!-- Âä†ËΩΩÁä∂ÊÄÅ -->
                        <div v-if="loading" class="flex flex-col items-center justify-center py-20">
                            <span class="loading loading-spinner loading-lg"></span>
                            <p class="mt-4 text-base-content/60">Âä†ËΩΩ‰∏≠...</p>
                        </div>

                    

                        <!-- Á¨îËÆ∞Âç°ÁâáÁΩëÊ†º -->
                        <div v-else class="grid grid-cols-1 gap-4 justify-items-center">
                             


                            <div v-for="note in notes"
                                 :key="note.pin.id"
                                 @click="goToDetail(note.pin.id)"
                                 class="card bg-base-100 shadow-md hover:shadow-xl transition-shadow cursor-pointer w-full">
                                <div class="card-body">
                                    <div class="flex items-start justify-between mb-2">
                                        <h3 class="card-title text-lg line-clamp-2">
                                            {{ note.noteData.title || 'Êó†Ê†áÈ¢ò' }}
                                        </h3>
                                    </div>

                                    <p v-if="note.noteData.subtitle" class="text-sm text-base-content/70 line-clamp-1 mb-2">
                                        {{ note.noteData.subtitle }}
                                    </p>

                                    <!-- Â∞ÅÈù¢ÂõæÁâá -->
                                    <div v-if="note.noteData.coverImg" class="w-full mb-3 rounded-lg overflow-hidden">
                                        <img
                                            :src="getNoteCover(note.noteData.coverImg)"
                                            :alt="note.noteData.title || 'Á¨îËÆ∞Â∞ÅÈù¢'"
                                            class="w-full h-48 object-cover hover:scale-105 transition-transform duration-300"
                                            @error="$event.target.style.display='none'"
                                        />
                                    </div>

                                    <p v-if="note.noteData.content" class="text-sm text-base-content/60 line-clamp-3 mb-3">
                                        {{ note.noteData.content }}
                                    </p>

                                    <!-- Áî®Êà∑‰ø°ÊÅØÂíåÊó∂Èó¥ -->
                                    <div class="flex items-center gap-2 mt-2">
                                        <!-- Âä†ËΩΩ‰∏≠ÁöÑÂç†‰ΩçÁ¨¶ -->
                                        <template v-if="isUserInfoLoading(note.pin.id)">
                                            <div class="skeleton w-8 h-8 rounded shrink-0"></div>
                                            <span class="skeleton h-4 w-20"></span>
                                            <span class="text-xs text-base-content/50 ml-auto">
                                                {{ formatTime(note.pin.timestamp) }}
                                            </span>
                                        </template>
                                        <!-- Âä†ËΩΩÂÆåÊàêÂêéÊòæÁ§∫ÁúüÂÆûÊï∞ÊçÆ -->
                                        <template v-else>
                                          <div class="flex items-center ">
                                              <UserAvatar
                                                :image="note?.userInfo?.avatar"
                                                :meta-id="note?.userInfo?.metaid"
                                                :name="note?.userInfo?.name || note?.userInfo?.metaid?.slice(0,6)"
                                                class="rounded shrink-0"
                                            />
                                            <span class="text-sm ml-2 font-medium ">
                                                {{ note?.userInfo?.name || note?.userInfo?.metaid?.slice(0,6) || 'ÂåøÂêç' }}
                                            </span>
                                            </div>
                                            <span class="text-xs text-base-content/50 ml-auto">
                                                {{ formatTime(note.pin.timestamp) }}
                                            </span>
                                        </template>
                                    </div>

                                    <!-- Ê†áÁ≠æ -->
                                    <div v-if="note.noteData.tags && note.noteData.tags.length > 0" class="flex flex-wrap gap-1 mt-2">
                                        <span v-for="tag in note.noteData.tags.slice(0, 3)"
                                              :key="tag"
                                              class="badge badge-sm badge-outline">
                                            {{ tag }}
                                        </span>
                                    </div>

                                    <div v-if="note.noteData.attachments && note.noteData.attachments.length > 0"
                                         class="flex items-center gap-1 mt-2 text-xs text-base-content/60">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"/>
                                        </svg>
                                        {{ note.noteData.attachments.length }} ‰∏™ÈôÑ‰ª∂
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- ÂàÜÈ°µÂô® -->
                        <div v-if="notes.length > 0 && totalPages > 1" class="pagination-container">
                            <button
                                class="btn btn-sm btn-outline"
                                :disabled="currentPage === 1"
                                @click="handlePageChange(currentPage - 1)">
                                ‰∏ä‰∏ÄÈ°µ
                            </button>

                            <div class="flex gap-1 flex-wrap justify-center">
                                <button
                                    v-for="page in getPageNumbers()"
                                    :key="page"
                                    :class="['btn btn-sm', page === currentPage ? 'btn-primary' : 'btn-outline', page === -1 ? 'btn-disabled' : '']"
                                    :disabled="page === -1"
                                    @click="page !== -1 && handlePageChange(page)">
                                    {{ page === -1 ? '...' : page }}
                                </button>
                            </div>

                            <button
                                class="btn btn-sm btn-outline"
                                :disabled="currentPage === totalPages"
                                @click="handlePageChange(currentPage + 1)">
                                ‰∏ã‰∏ÄÈ°µ
                            </button>
                        </div>
                    </div>
                </div>
            `,
            setup() {
                const userStore = useUserStore();
                const { showToast } = useToast();

                const isAuthorized = computed(() => userStore.isAuthorized);
                const notes = ref([]);
                const loading = ref(false);
                const total = ref(0);
                const currentPage = ref(1);
                const pageSize = 20;
                // ËøΩË∏™ÊØè‰∏™ note ÁöÑ userInfo Âä†ËΩΩÁä∂ÊÄÅ
                const userInfoLoadingMap = ref(new Map());

                // ËÆ°ÁÆóÊÄªÈ°µÊï∞
                const totalPages = computed(() => {
                    if (total.value === 0 || notes.value.length === 0) return 0;
                    return Math.ceil(total.value / pageSize);
                });

                // Âä†ËΩΩÁ¨îËÆ∞ÂàóË°®
                const loadNotes = async (page = 1) => {
                    

                    if (loading.value) return;
                    loading.value = true;

                    try {
                        const cursor = (page - 1) * pageSize;
                        console.log('ÂºÄÂßãÂä†ËΩΩÁ¨îËÆ∞ÂàóË°®Ôºåpage:', page, 'cursor:', cursor, 'size:', pageSize);
                        const response = await getNoteList({
                            cursor: cursor,
                            size: pageSize
                        });

                        console.log('Ëé∑ÂèñÂà∞ÁöÑÁ¨îËÆ∞ÂàóË°®ÂìçÂ∫î:', response);

                        if (!response || !response.list || !Array.isArray(response.list)) {
                            console.warn('ÂìçÂ∫îÊï∞ÊçÆÊ†ºÂºè‰∏çÊ≠£Á°Æ:', response);
                            showToast('Ëé∑ÂèñÁ¨îËÆ∞ÂàóË°®Â§±Ë¥•ÔºöÊï∞ÊçÆÊ†ºÂºèÈîôËØØ', 'error');
                            return;
                        }

                        // Ëß£ÊûêÁ¨îËÆ∞Êï∞ÊçÆ
                        const noteItems = [];
                        for (const pin of response.list) {
                            try {
                                // Ë∑≥ËøáÊí§ÈîÄÁöÑÁ¨îËÆ∞
                                if (pin.operation === 'revoke') {
                                    console.log('Ë∑≥ËøáÂ∑≤Êí§ÈîÄÁöÑÁ¨îËÆ∞:', pin.id);
                                    continue;
                                }

                                let noteData;
                                try {
                                    if (typeof pin.contentSummary === 'string') {
                                        noteData = JSON.parse(pin.contentSummary);
                                    } else {
                                        noteData = pin.contentSummary;
                                    }
                                } catch (parseError) {
                                    console.error('Ëß£ÊûêÁ¨îËÆ∞Êï∞ÊçÆÂ§±Ë¥•:', pin.id, parseError);
                                    continue;
                                }

                                if (noteData) {
                                    if(Number(noteData.encryption) == 0){
                                    noteItems.push({
                                        pin,
                                        noteData
                                    });
                                    }
                                  
                                }
                            } catch (error) {
                                console.error('Â§ÑÁêÜÁ¨îËÆ∞Êï∞ÊçÆÂ§±Ë¥•:', pin.id, error);
                            }
                        }

                        console.log('ÊàêÂäüËß£ÊûêÁöÑÁ¨îËÆ∞Êï∞Èáè:', noteItems.length);

                        notes.value = noteItems;
                        total.value = response.total || 0;
                        currentPage.value = page;

                        // ÂºÇÊ≠•Âä†ËΩΩÊØè‰∏™Á¨îËÆ∞ÁöÑÁî®Êà∑‰ø°ÊÅØ
                        for (const noteItem of noteItems) {
                            if (noteItem.pin.address) {
                                loadUserInfo(noteItem);
                            }
                        }

                    } catch (error) {
                        console.error('Âä†ËΩΩÁ¨îËÆ∞ÂàóË°®Â§±Ë¥•:', error);
                        showToast('Âä†ËΩΩÁ¨îËÆ∞ÂàóË°®Â§±Ë¥•: ' + (error.message || 'Êú™Áü•ÈîôËØØ'), 'error');
                    } finally {
                        loading.value = false;
                    }
                };

                // Âà§Êñ≠Êüê‰∏™ note ÁöÑ userInfo ÊòØÂê¶Ê≠£Âú®Âä†ËΩΩ
                const isUserInfoLoading = (noteId) => {
                    return userInfoLoadingMap.value.get(noteId) === true;
                };

                   const getNoteCover = (coverImg) => {
                    try {
                        
                        if (coverImg) {
                            
                            if (coverImg.startsWith('metafile://')) {
                                const pinId = coverImg.replace('metafile://', '');
                                return `https://man.metaid.io/content/${pinId}`;
                            }
                            return coverImg || '';
                        }
                        return '';
                    } catch (error) {
                        return '';
                    }
                };

                // ÂºÇÊ≠•Âä†ËΩΩÁî®Êà∑‰ø°ÊÅØ
                const loadUserInfo = async (noteItem) => {
                    if (!noteItem.pin.address) return;

                    try {
                        // Ê†áËÆ∞ËØ• note ÁöÑ userInfo Ê≠£Âú®Âä†ËΩΩ
                        userInfoLoadingMap.value.set(noteItem.pin.id, true);

                        const userInfo = await getUserInfoByAddress(noteItem.pin.address);

                        // ÊâæÂà∞ÂØπÂ∫îÁöÑ note Âπ∂Êõ¥Êñ∞ userInfo
                        const noteIndex = notes.value.findIndex(n => n.pin.id === noteItem.pin.id);
                        if (noteIndex !== -1) {
                            notes.value[noteIndex].userInfo = userInfo;
                        }
                    } catch (error) {
                        console.error(`Failed to load user info for note ${noteItem.pin.id}:`, error);
                    } finally {
                        // Ê†áËÆ∞ËØ• note ÁöÑ userInfo Âä†ËΩΩÂÆåÊàê
                        userInfoLoadingMap.value.set(noteItem.pin.id, false);
                    }
                };

                // ÂàáÊç¢È°µÁ†Å
                const handlePageChange = (page) => {
                    if (page < 1 || page > totalPages.value || page === currentPage.value) {
                        return;
                    }
                    loadNotes(page);
                    // ÊªöÂä®Âà∞È°∂ÈÉ®
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                };

                // Ëé∑ÂèñË¶ÅÊòæÁ§∫ÁöÑÈ°µÁ†ÅÊï∞ÁªÑ
                const getPageNumbers = () => {
                    const total = totalPages.value;
                    const current = currentPage.value;
                    const pages = [];

                    if (total <= 7) {
                        // Â¶ÇÊûúÊÄªÈ°µÊï∞Â∞è‰∫éÁ≠â‰∫é7ÔºåÊòæÁ§∫ÊâÄÊúâÈ°µÁ†Å
                        for (let i = 1; i <= total; i++) {
                            pages.push(i);
                        }
                    } else {
                        // ÊÄªÊòØÊòæÁ§∫Á¨¨‰∏ÄÈ°µ
                        pages.push(1);

                        if (current <= 3) {
                            // ÂΩìÂâçÈ°µÂú®ÂâçÈù¢
                            pages.push(2, 3, 4, 5);
                            pages.push(-1); // ÁúÅÁï•Âè∑
                            pages.push(total);
                        } else if (current >= total - 2) {
                            // ÂΩìÂâçÈ°µÂú®ÂêéÈù¢
                            pages.push(-1); // ÁúÅÁï•Âè∑
                            pages.push(total - 4, total - 3, total - 2, total - 1, total);
                        } else {
                            // ÂΩìÂâçÈ°µÂú®‰∏≠Èó¥
                            pages.push(-1); // ÁúÅÁï•Âè∑
                            pages.push(current - 1, current, current + 1);
                            pages.push(-1); // ÁúÅÁï•Âè∑
                            pages.push(total);
                        }
                    }

                    return pages;
                };

                // Ë∑≥ËΩ¨Âà∞ÂàõÂª∫È°µÈù¢
                const goToCreate = () => {
                    router.push('/note/new');
                };

                // Ë∑≥ËΩ¨Âà∞ËØ¶ÊÉÖÈ°µÈù¢
                const goToDetail = (id) => {
                    router.push(`/note/${id}`);
                };

                // Ê†ºÂºèÂåñÊó∂Èó¥
                const formatTime = (timestamp) => {
                    const date = new Date(timestamp * 1000);
                    const now = new Date();
                    const diff = now - date;

                    const minute = 60 * 1000;
                    const hour = 60 * minute;
                    const day = 24 * hour;

                    if (diff < hour) {
                        return Math.floor(diff / minute) + ' ÂàÜÈíüÂâç';
                    } else if (diff < day) {
                        return Math.floor(diff / hour) + ' Â∞èÊó∂Ââç';
                    } else if (diff < 7 * day) {
                        return Math.floor(diff / day) + ' Â§©Ââç';
                    } else {
                        return date.toLocaleDateString('zh-CN');
                    }
                };

                // ÁõëÂê¨ÊéàÊùÉÁä∂ÊÄÅÂèòÂåñ
             

                // ÂàùÂßãÂä†ËΩΩ
                onMounted(() => {
                    loadNotes(1);
                });

                return {
                    isAuthorized,
                    notes,
                    loading,
                    total,
                    currentPage,
                    totalPages,
                    handlePageChange,
                    getPageNumbers,
                    goToCreate,
                    goToDetail,
                    formatTime,
                    getNoteCover,
                    isUserInfoLoading
                };
            }
        };

        // NoteEditor - Á¨îËÆ∞ÁºñËæëÂô®ÁªÑ‰ª∂
        const NoteEditor = {
            template: `
                <div class="min-h-screen bg-base-200 pb-20">
                    <div class="container mx-auto px-4 py-6 max-w-4xl">
                        <!-- Â§¥ÈÉ® -->
                        <div class="flex items-center justify-between mb-6">
                            <button @click="goBack" class="btn btn-ghost gap-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                                </svg>
                                ËøîÂõû
                            </button>
                            <h1 class="text-2xl font-bold">{{ isEdit ? 'ÁºñËæëÁ¨îËÆ∞' : 'Êñ∞Âª∫Á¨îËÆ∞' }}</h1>
                            <button @click="saveNote"
                                    :disabled="!canSave || saving"
                                    :class="['btn', canSave && !saving ? 'btn-primary' : 'btn-disabled']">
                                {{ saving ? 'ÂèëÂ∏É‰∏≠...' : 'ÂèëÂ∏É' }}
                            </button>
                        </div>

                        <!-- ÁºñËæëÂô®Ë°®Âçï -->
                        <div class="card bg-base-100 shadow-xl mx-auto">
                            <div class="card-body space-y-4">
                                <!-- Ê†áÈ¢òËæìÂÖ• -->
                                <div class="form-control">
                                    <label class="label">
                                        <span class="label-text font-semibold">Ê†áÈ¢ò *</span>
                                    </label>
                                    <input v-model="noteData.title"
                                           @input="handleContentChange"
                                           type="text"
                                           placeholder="ËØ∑ËæìÂÖ•Á¨îËÆ∞Ê†áÈ¢ò"
                                           maxlength="100"
                                           class="input input-bordered w-full" />
                                </div>

                                <!-- ÂâØÊ†áÈ¢òËæìÂÖ• -->
                                <div class="form-control">
                                    <label class="label">
                                        <span class="label-text font-semibold">ÂâØÊ†áÈ¢ò</span>
                                    </label>
                                    <input v-model="noteData.subtitle"
                                           @input="handleContentChange"
                                           type="text"
                                           placeholder="ËØ∑ËæìÂÖ•ÂâØÊ†áÈ¢òÔºàÂèØÈÄâÔºâ"
                                           maxlength="200"
                                           class="input input-bordered w-full" />
                                </div>

                                <!-- Á¨îËÆ∞ÂèØËßÅÊÄß -->
                                <div class="form-control">
                                    <label class="label">
                                        <span class="label-text font-semibold">Á¨îËÆ∞ÂèØËßÅÊÄß</span>
                                    </label>
                                    <div class="flex gap-4">
                                        <label class="flex items-center gap-2 cursor-pointer">
                                            <input type="radio"
                                                   v-model="privacySetting"
                                                   value="0"
                                                   @change="handleContentChange"
                                                   class="radio radio-primary" />
                                            <span class="label-text">ÂÖ¨ÂºÄ</span>
                                        </label>
                                        <label class="flex items-center gap-2 cursor-pointer">
                                            <input type="radio"
                                                   v-model="privacySetting"
                                                   value="aes"
                                                   @change="handleContentChange"
                                                   class="radio radio-primary" />
                                            <span class="label-text">ÁßÅÂØÜ</span>
                                        </label>
                                    </div>
                                </div>

                                <!-- Â∞ÅÈù¢ÂõæÁâá -->
                                <div class="form-control">
                                    <label class="label">
                                        <span class="label-text font-semibold">Â∞ÅÈù¢ÂõæÁâáÔºàÂèØÈÄâÔºâ</span>
                                    </label>
                                    <div v-if="coverImg" class="relative inline-block">
                                        <img :src="getCoverUrl(coverImg)" alt="cover" class="max-w-xs rounded-lg shadow-md" />
                                        <button @click="removeCover"
                                                class="btn btn-error btn-sm !mt-2">
                                            Âà†Èô§Â∞ÅÈù¢
                                        </button>
                                    </div>
                                    <div v-else>
                                        <input type="file"
                                               ref="coverInput"
                                               @change="handleCoverUpload"
                                               accept="image/*"
                                               class="hidden" />
                                        <button @click="triggerCoverUpload"
                                                class="btn btn-outline btn-primary">
                                            ‰∏ä‰º†Â∞ÅÈù¢ÂõæÁâá
                                        </button>
                                    </div>
                                </div>

                                <!-- Vditor ÁºñËæëÂô® -->
                                <div class="form-control">
                                    <label class="label">
                                        <span class="label-text font-semibold">ÂÜÖÂÆπ *</span>
                                    </label>
                                    <div id="vditor" class="border border-base-300 rounded-lg overflow-hidden"></div>
                                </div>

                                <!-- ÈôÑ‰ª∂È¢ÑËßà -->
                                <div v-if="attachments.length > 0" class="attachment-preview">
                                    <div class="preview-header">
                                        <label class="preview-label">ÈôÑ‰ª∂È¢ÑËßà ({{ attachments.length }})</label>
                                    </div>
                                    <div class="preview-list">
                                        <div v-for="attachment in attachments"
                                             :key="attachment.id"
                                             class="preview-item">
                                            <!-- Image Preview -->
                                            <div v-if="getFileType(attachment.type) === 'image'"
                                                 class="preview-content preview-image"
                                                 @click="handlePreviewAttachment(attachment)">
                                                <img :src="attachment.blobUrl" :alt="attachment.name" />
                                            </div>

                                            <!-- Video Preview -->
                                            <div v-else-if="getFileType(attachment.type) === 'video'"
                                                 class="preview-content preview-video">
                                                <video :src="attachment.blobUrl" controls preload="metadata"></video>
                                            </div>

                                            <!-- Audio Preview -->
                                            <div v-else-if="getFileType(attachment.type) === 'audio'"
                                                 class="preview-content preview-audio">
                                                <div class="audio-icon">
                                                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                        <path d="M9 18V5l12-2v13"></path>
                                                        <circle cx="6" cy="18" r="3"></circle>
                                                        <circle cx="18" cy="16" r="3"></circle>
                                                    </svg>
                                                </div>
                                                <audio :src="attachment.blobUrl" controls class="audio-player"></audio>
                                            </div>

                                            <!-- PDF Preview -->
                                            <div v-else-if="getFileType(attachment.type) === 'pdf'"
                                                 class="preview-content preview-document"
                                                 @click="handlePreviewAttachment(attachment)">
                                                <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                                    <polyline points="14 2 14 8 20 8"></polyline>
                                                    <text x="12" y="16" text-anchor="middle" font-size="6" fill="currentColor">PDF</text>
                                                </svg>
                                            </div>

                                            <!-- Other Document Preview -->
                                            <div v-else
                                                 class="preview-content preview-document"
                                                 @click="handlePreviewAttachment(attachment)">
                                                <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                                    <polyline points="14 2 14 8 20 8"></polyline>
                                                    <line x1="16" y1="13" x2="8" y2="13"></line>
                                                    <line x1="16" y1="17" x2="8" y2="17"></line>
                                                    <polyline points="10 9 9 9 8 9"></polyline>
                                                </svg>
                                                <span class="file-type-label">{{ getFileExtension(attachment.name) }}</span>
                                            </div>

                                            <div class="preview-info">
                                                <span class="file-name" :title="attachment.name">{{ attachment.name }}</span>
                                                <span class="file-size">{{ formatFileSize(attachment.file.size) }}</span>
                                            </div>
                                            <button @click="handleDeleteAttachment(attachment.id)"
                                                    class="delete-btn"
                                                    title="Âà†Èô§ÈôÑ‰ª∂">
                                                <svg xmlns="http://www.w3.org/2000/svg"
                                                     width="16"
                                                     height="16"
                                                     viewBox="0 0 24 24"
                                                     fill="none"
                                                     stroke="currentColor"
                                                     stroke-width="2"
                                                     stroke-linecap="round"
                                                     stroke-linejoin="round">
                                                    <path d="M3 6h18"></path>
                                                    <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                                                    <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                                                </svg>
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                <!-- Ê†áÁ≠æËæìÂÖ• -->
                                <div class="form-control">
                                    <label class="label">
                                        <span class="label-text font-semibold">Ê†áÁ≠æ</span>
                                    </label>
                                    <div class="flex flex-wrap gap-2 p-3 border rounded-lg min-h-[50px]">
                                        <span v-for="(tag, index) in noteData.tags"
                                              :key="index"
                                              class="badge badge-primary gap-2">
                                            {{ tag }}
                                            <button @click="removeTag(index)" class="text-lg">√ó</button>
                                        </span>
                                        <input v-model="newTag"
                                               type="text"
                                               placeholder="ËæìÂÖ•Ê†áÁ≠æÂêéÊåâÂõûËΩ¶Ê∑ªÂä†"
                                               @keyup.enter="addTag"
                                               class="flex-1 min-w-[200px] outline-none" />
                                    </div>
                                </div>

                                <!-- Â∑≤ÊúâÈôÑ‰ª∂ÊòæÁ§∫ÔºàÁºñËæëÊ®°ÂºèÔºâ -->
                                <div v-if="existingAttachments.length > 0" class="form-control">
                                    <label class="label">
                                        <span class="label-text font-semibold">Â∑≤ÊúâÈôÑ‰ª∂ ({{ existingAttachments.length }})</span>
                                    </label>
                                    <div class="attachments-list grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div v-for="(attachment, index) in existingAttachments"
                                             :key="index"
                                             class="attachment-item border border-base-300 rounded-lg overflow-hidden bg-base-100">
                                            <!-- ÂõæÁâáÈ¢ÑËßà -->
                                            <div v-if="isImageAttachment(attachment)"
                                                 class="relative">
                                                <img :src="getAttachmentUrl(attachment)"
                                                     :alt="'ÈôÑ‰ª∂' + (index + 1)"
                                                     class="w-full h-48 object-cover"/>
                                                <div class="absolute bottom-0 left-0 right-0 bg-black bg-opacity-50 text-white text-xs p-2">
                                                    <p class="truncate">ÂõæÁâáÈôÑ‰ª∂</p>
                                                </div>
                                            </div>

                                            <!-- ËßÜÈ¢ëÈ¢ÑËßà -->
                                            <div v-else-if="isVideoAttachment(attachment)"
                                                 class="relative">
                                                <video :src="getAttachmentUrl(attachment)"
                                                       controls
                                                       class="w-full h-48 object-cover bg-black">
                                                    ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅËßÜÈ¢ëÊí≠Êîæ
                                                </video>
                                            </div>

                                            <!-- Èü≥È¢ëÈ¢ÑËßà -->
                                            <div v-else-if="isAudioAttachment(attachment)"
                                                 class="p-4">
                                                <div class="flex items-center gap-3 mb-3">
                                                    <svg class="w-10 h-10 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"/>
                                                    </svg>
                                                    <div class="flex-1">
                                                        <p class="font-medium text-sm">Èü≥È¢ëÊñá‰ª∂</p>
                                                        <p class="text-xs text-base-content/60 break-all">{{ getAttachmentFileName(attachment) }}</p>
                                                    </div>
                                                </div>
                                                <audio :src="getAttachmentUrl(attachment)"
                                                       controls
                                                       class="w-full">
                                                </audio>
                                            </div>

                                            <!-- ÂÖ∂‰ªñÊñá‰ª∂Á±ªÂûã -->
                                            <div v-else class="p-4">
                                                <div class="flex items-start gap-3 mb-3">
                                                    <div class="flex-shrink-0">
                                                        <svg class="w-10 h-10 text-base-content/60" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                                                        </svg>
                                                    </div>
                                                    <div class="flex-1 min-w-0">
                                                        <p class="font-medium text-sm mb-1">{{ getAttachmentFileName(attachment) }}</p>
                                                    </div>
                                                </div>
                                            </div>

                                            <!-- Âà†Èô§ÊåâÈíÆ -->
                                            <div class="p-2 border-t border-base-300">
                                                <button @click="deleteExistingAttachment(index)"
                                                        class="btn btn-error btn-sm btn-block gap-2">
                                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                                                    </svg>
                                                    Âà†Èô§ÈôÑ‰ª∂
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `,
            setup() {
                const userStore = useUserStore();
                const { showToast } = useToast();

                const isEdit = computed(() => {
                    const path = router.currentRoute.value.path;
                    return path.includes('/edit');
                });

                const pinId = computed(() => router.currentRoute.value.params.id);

                const noteData = ref({
                    title: '',
                    subtitle: '',
                    coverImg:'',
                    content: '',
                    contentType: 'text/markdown',
                    encryption: '0',
                    createTime: '',
                    tags: [],
                    attachments: []
                });

                const existingAttachments = ref([]);
                const newTag = ref('');
                const saving = ref(false);
                const privacySetting = ref('0'); // ÈöêÁßÅËÆæÁΩÆ
                const coverImg = ref(''); // Â∞ÅÈù¢ÂõæÁâá URL
                const coverFile = ref(null); // Â∞ÅÈù¢ÂõæÁâáÊñá‰ª∂
                const coverInput = ref(null); // Â∞ÅÈù¢ËæìÂÖ• ref

                // ÈôÑ‰ª∂ÁÆ°ÁêÜ
                const attachments = ref([]); // ÈôÑ‰ª∂ÂàóË°®
                const attachmentMap = ref(new Map()); // mediafile://mediaId -> mediaId
                const mediaUrlMap = ref(new Map()); // mediafile://mediaId -> dataURL

                // ËçâÁ®øÁÆ°ÁêÜ
                const hasUnsavedChanges = ref(false); // ÊòØÂê¶ÊúâÊú™‰øùÂ≠òÁöÑÊõ¥Êîπ
                const autoSaveTimer = ref(null); // Ëá™Âä®‰øùÂ≠òÂÆöÊó∂Âô®
                const lastSavedContent = ref(''); // ÊúÄÂêé‰øùÂ≠òÁöÑÂÜÖÂÆπ
                const currentDraftId = ref(null); // ÂΩìÂâçËçâÁ®øID

                let vditor = null; // Vditor ÂÆû‰æã
                let nextMediaId = 1; // Áî®‰∫éÁîüÊàê‰∏¥Êó∂ mediaId

                const canSave = computed(() => {
                    return noteData.value.title.trim() !== '' && noteData.value.content.trim() !== '';
                });

                // ÂõæÁâáÂéãÁº©ÂáΩÊï∞
                const compressImage = async (file) => {
                    if (!file.type.startsWith('image/')) {
                        return file;
                    }

                    try {
                        if (typeof imageCompression !== 'undefined') {
                            const options = {
                                maxSizeMB: 1,
                                maxWidthOrHeight: 1920,
                                useWebWorker: false
                            };
                            return await imageCompression(file, options);
                        }
                        return file;
                    } catch (error) {
                        console.error('ÂõæÁâáÂéãÁº©Â§±Ë¥•:', error);
                        return file;
                    }
                };

                // Â∞Ü Blob ËΩ¨Êç¢‰∏∫ base64 data URL
                const blobToDataURL = (blob) => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = () => reject(new Error('Failed to convert blob to data URL'));
                        reader.readAsDataURL(blob);
                    });
                };

                // Ëß¶ÂèëÂ∞ÅÈù¢‰∏ä‰º†
                const triggerCoverUpload = () => {
                    coverInput.value?.click();
                };

                // Â§ÑÁêÜÂ∞ÅÈù¢‰∏ä‰º†
                const handleCoverUpload = async (event) => {
                    const target = event.target;
                    const file = target.files?.[0];
                    if (!file) return;

                    try {
                        const compressedFile = await compressImage(file);
                        const dataUrl = await blobToDataURL(compressedFile);

                        coverImg.value = dataUrl;
                        coverFile.value = compressedFile;
                        handleContentChange();
                    } catch (error) {
                        console.error('Â∞ÅÈù¢‰∏ä‰º†Â§±Ë¥•:', error);
                        showToast('Â∞ÅÈù¢‰∏ä‰º†Â§±Ë¥•', 'error');
                    }
                };

                // Âà†Èô§Â∞ÅÈù¢
                const removeCover = () => {
                    coverImg.value = '';
                    coverFile.value = null;
                    handleContentChange();
                };

                // Ëé∑ÂèñÊñá‰ª∂Á±ªÂûã
                const getFileType = (mimeType) => {
                    if (mimeType.startsWith('image/')) {
                        return 'image';
                    } else if (mimeType.startsWith('video/')) {
                        return 'video';
                    } else if (mimeType.startsWith('audio/')) {
                        return 'audio';
                    } else if (mimeType === 'application/pdf') {
                        return 'pdf';
                    }
                    return 'document';
                };

                // Ëé∑ÂèñÊñá‰ª∂Êâ©Â±ïÂêç
                const getFileExtension = (fileName) => {
                    const parts = fileName.split('.');
                    if (parts.length > 1) {
                        return parts[parts.length - 1].toUpperCase();
                    }
                    return 'FILE';
                };

                // Ê†ºÂºèÂåñÊñá‰ª∂Â§ßÂ∞è
                const formatFileSize = (bytes) => {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
                };

                // Âà†Èô§ÈôÑ‰ª∂
                const handleDeleteAttachment = async (mediaId) => {
                    try {
                        // ‰ªéÊï∞ÁªÑ‰∏≠ÁßªÈô§
                        const index = attachments.value.findIndex(m => m.id === mediaId);
                        if (index !== -1) {
                            const mediaFileUrl = `metafile://${mediaId}`;

                            // ‰ªéÊò†Â∞Ñ‰∏≠ÁßªÈô§
                            attachmentMap.value.delete(mediaFileUrl);
                            mediaUrlMap.value.delete(mediaFileUrl);

                            // ‰ªéattachmentsÊï∞ÁªÑ‰∏≠ÁßªÈô§
                            attachments.value.splice(index, 1);

                            // ‰ªéÁºñËæëÂô®ÂÜÖÂÆπ‰∏≠ÁßªÈô§ÂØπÂ∫îÁöÑÂõæÁâáÊ†áËÆ∞
                            if (vditor) {
                                const currentContent = vditor.getValue();
                                const imgRegex = new RegExp(`!\\[.*?\\]\\(${mediaFileUrl}\\)`, 'g');
                                const updatedContent = currentContent.replace(imgRegex, '');
                                vditor.setValue(updatedContent);
                                noteData.value.content = updatedContent;
                            }

                            showToast('ÈôÑ‰ª∂Â∑≤Âà†Èô§', 'success');
                        }
                    } catch (error) {
                        console.error('Delete attachment failed:', error);
                        showToast('Âà†Èô§ÈôÑ‰ª∂Â§±Ë¥•', 'error');
                    }
                };

                // È¢ÑËßàÈôÑ‰ª∂
                const handlePreviewAttachment = (attachment) => {
                    const fileType = getFileType(attachment.type);
                    const previewWindow = window.open('', '_blank');

                    if (!previewWindow) return;

                    let content = '';

                    switch (fileType) {
                        case 'image':
                            content = `
                                <!DOCTYPE html>
                                <html>
                                <head>
                                    <title>${attachment.name}</title>
                                    <style>
                                        body {
                                            margin: 0;
                                            display: flex;
                                            justify-content: center;
                                            align-items: center;
                                            min-height: 100vh;
                                            background: #000;
                                        }
                                        img {
                                            max-width: 100%;
                                            max-height: 100vh;
                                            object-fit: contain;
                                        }
                                    </style>
                                </head>
                                <body>
                                    <img src="${attachment.blobUrl}" alt="${attachment.name}" />
                                </body>
                                </html>
                            `;
                            break;
                        case 'video':
                            content = `
                                <!DOCTYPE html>
                                <html>
                                <head>
                                    <title>${attachment.name}</title>
                                    <style>
                                        body {
                                            margin: 0;
                                            display: flex;
                                            justify-content: center;
                                            align-items: center;
                                            min-height: 100vh;
                                            background: #000;
                                        }
                                        video {
                                            max-width: 100%;
                                            max-height: 100vh;
                                        }
                                    </style>
                                </head>
                                <body>
                                    <video src="${attachment.blobUrl}" controls autoplay style="max-width: 100%; max-height: 100vh;">
                                        Your browser does not support the video tag.
                                    </video>
                                </body>
                                </html>
                            `;
                            break;
                        case 'audio':
                            content = `
                                <!DOCTYPE html>
                                <html>
                                <head>
                                    <title>${attachment.name}</title>
                                    <style>
                                        body {
                                            margin: 0;
                                            display: flex;
                                            flex-direction: column;
                                            justify-content: center;
                                            align-items: center;
                                            min-height: 100vh;
                                            background: #1a1a1a;
                                            color: #fff;
                                        }
                                        h2 {
                                            margin-bottom: 2rem;
                                        }
                                        audio {
                                            min-width: 400px;
                                        }
                                    </style>
                                </head>
                                <body>
                                    <h2>${attachment.name}</h2>
                                    <audio src="${attachment.blobUrl}" controls autoplay></audio>
                                </body>
                                </html>
                            `;
                            break;
                        case 'pdf':
                            content = `
                                <!DOCTYPE html>
                                <html>
                                <head>
                                    <title>${attachment.name}</title>
                                    <style>
                                        body {
                                            margin: 0;
                                        }
                                        iframe {
                                            width: 100vw;
                                            height: 100vh;
                                            border: none;
                                        }
                                    </style>
                                </head>
                                <body>
                                    <iframe src="${attachment.blobUrl}"></iframe>
                                </body>
                                </html>
                            `;
                            break;
                        default:
                            content = `
                                <!DOCTYPE html>
                                <html>
                                <head>
                                    <title>${attachment.name}</title>
                                    <style>
                                        body {
                                            margin: 0;
                                            display: flex;
                                            flex-direction: column;
                                            justify-content: center;
                                            align-items: center;
                                            min-height: 100vh;
                                            background: #1a1a1a;
                                            color: #fff;
                                        }
                                    </style>
                                </head>
                                <body>
                                    <h2>${attachment.name}</h2>
                                    <p>Êó†Ê≥ïÈ¢ÑËßàÊ≠§Êñá‰ª∂Á±ªÂûã</p>
                                    <a href="${attachment.blobUrl}" download="${attachment.name}" style="color: #149dd3;">‰∏ãËΩΩÊñá‰ª∂</a>
                                </body>
                                </html>
                            `;
                    }

                    previewWindow.document.write(content);
                    previewWindow.document.close();
                };

                // ÂàùÂßãÂåñ Vditor ÁºñËæëÂô®
                const initEditor = () => {
                    if (typeof window.Vditor === 'undefined') {
                        console.error('Vditor is not loaded');
                        showToast('ÁºñËæëÂô®Âä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï', 'error');
                        return;
                    }

                    try {
                        vditor = new window.Vditor('vditor', {
                            height: '500px',
                            minHeight: 400,
                            placeholder: 'Âú®Ê≠§ËæìÂÖ•Á¨îËÆ∞ÂÜÖÂÆπÔºåÊîØÊåÅ Markdown ËØ≠Ê≥ï...',
                            theme: 'classic',
                            icon: 'material',
                            toolbar: [
                                'emoji',
                                'headings',
                                'bold',
                                'italic',
                                'strike',
                                '|',
                                'line',
                                'quote',
                                'list',
                                'ordered-list',
                                'check',
                                '|',
                                'code',
                                'inline-code',
                                'link',
                                'upload',
                                'table',
                                '|',
                                'undo',
                                'redo',
                                '|',
                                'edit-mode',
                                'preview',
                                'fullscreen'
                            ],
                            cache: {
                                enable: false
                            },
                            preview: {
                                markdown: {
                                    mark: true
                                },
                                transform: (html) => {
                                    // Âú®previewÊ∏≤ÊüìÊó∂ÔºåÂ∞Ü metafile:// ÊõøÊç¢‰∏∫ÂÆûÈôÖÁöÑ dataURL
                                    let transformedHtml = html;
                                    mediaUrlMap.value.forEach((dataUrl, mediaFileUrl) => {
                                        transformedHtml = transformedHtml.replace(
                                            new RegExp(`src="${mediaFileUrl}"`, 'g'),
                                            `src="${dataUrl}"`
                                        );
                                    });
                                    return transformedHtml;
                                }
                            },
                            upload: {
                                handler: async (files) => {
                                    const file = files[0];
                                    if (!file) return null;

                                    try {
                                        // ÂéãÁº©ÂõæÁâá
                                        const compressedFile = await compressImage(file);

                                        // ËΩ¨Êç¢‰∏∫ base64 data URL
                                        const dataUrl = await blobToDataURL(compressedFile);

                                        // ÁîüÊàê‰∏¥Êó∂ mediaId
                                        const mediaId = nextMediaId++;

                                        // ÁîüÊàê metafile:// Ê†ºÂºèÁöÑURL
                                        const mediaFileUrl = `metafile://${mediaId}`;

                                        // ‰øùÂ≠òÂà∞ÂÜÖÂ≠òÊò†Â∞Ñ
                                        attachmentMap.value.set(mediaFileUrl, mediaId);
                                        mediaUrlMap.value.set(mediaFileUrl, dataUrl);
                                        attachments.value.push({
                                            id: mediaId,
                                            blobUrl: dataUrl,
                                            file: compressedFile,
                                            type: file.type,
                                            name: file.name,
                                            createdAt: Date.now()
                                        });

                                        // ËøîÂõû metafile:// Ê†ºÂºèÁöÑURLÁªôÁºñËæëÂô®
                                        return JSON.stringify({
                                            data: {
                                                succMap: {
                                                    [file.name]: mediaFileUrl
                                                }
                                            }
                                        });
                                    } catch (error) {
                                        console.error('Upload failed:', error);
                                        showToast('‰∏ä‰º†Â§±Ë¥•', 'error');
                                        return null;
                                    }
                                }
                            },
                            after: () => {
                                if (vditor) {
                                    vditor.setValue(noteData.value.content || '');
                                }
                            },
                            input: (value) => {
                                noteData.value.content = value;
                                handleContentChange();
                            }
                        });
                    } catch (error) {
                        console.error('Failed to initialize Vditor:', error);
                        showToast('ÁºñËæëÂô®ÂàùÂßãÂåñÂ§±Ë¥•: ' + error.message, 'error');
                    }
                };

                // Âä†ËΩΩÁ¨îËÆ∞Êï∞ÊçÆÔºàÁºñËæëÊ®°ÂºèÔºâ
                const loadNote = async () => {
                    if (!isEdit.value || !pinId.value) return;

                    try {
                        const { noteData: data } = await getNoteDetail(pinId.value);
                        noteData.value = {
                            ...data,
                            tags: data.tags || [],
                            attachments: data.attachments || []
                        };
                        existingAttachments.value = data.attachments || [];

                        // ËÆæÁΩÆÂ∞ÅÈù¢ÂõæÁâá
                        if (data.coverImg) {
                            coverImg.value = data.coverImg;
                        }

                        // ËÆæÁΩÆÈöêÁßÅÁä∂ÊÄÅÔºàÊ†πÊçÆ encryption Â≠óÊÆµÔºâ
                        if (data.encryption && data.encryption !== '0') {
                            privacySetting.value = 'aes';
                        } else {
                            privacySetting.value = '0';
                        }

                        // Â§ÑÁêÜÂä†ÂØÜÂÜÖÂÆπÔºöÂ¶ÇÊûúÁ¨îËÆ∞ÊòØÂä†ÂØÜÁöÑÔºåÂÖàËß£ÂØÜÂÜçÊ∏≤Êüì
                        let contentToRender = noteData.value.content || '';
                        if (data.encryption && data.encryption !== '0') {
                            try {
                                // Ëé∑ÂèñÁ≠æÂêçÂØÜÈí•
                                let sigKey = queryCurrentSigKey();
                                if (!sigKey) {
                                    // Â¶ÇÊûúÊ≤°ÊúâÁ≠æÂêçÂØÜÈí•ÔºåÂÖàÁ≠æÂêç
                                    sigKey = await signMessageAndStore();
                                }

                                if (sigKey) {
                                    // Ëß£ÂØÜÂÜÖÂÆπ
                                    contentToRender = await decryptGCM(noteData.value.content, sigKey);
                                    // Êõ¥Êñ∞noteData‰∏≠ÁöÑÂÜÖÂÆπ‰∏∫Ëß£ÂØÜÂêéÁöÑÂÜÖÂÆπÔºåÊñπ‰æøÂêéÁª≠ÁºñËæë
                                    noteData.value.content = contentToRender;
                                    console.log('Á¨îËÆ∞ÂÜÖÂÆπÂ∑≤Ëß£ÂØÜ');
                                } else {
                                    showToast('Êó†Ê≥ïËé∑ÂèñËß£ÂØÜÂØÜÈí•ÔºåÊó†Ê≥ïÁºñËæëÂä†ÂØÜÁ¨îËÆ∞', 'error');
                                    router.push('/');
                                    return;
                                }
                            } catch (decryptError) {
                                console.error('Ëß£ÂØÜÁ¨îËÆ∞ÂÜÖÂÆπÂ§±Ë¥•:', decryptError);
                                showToast('Ëß£ÂØÜÂ§±Ë¥•ÔºåÊó†Ê≥ïÁºñËæëÊ≠§Á¨îËÆ∞', 'error');
                                router.push('/');
                                return;
                            }
                        }

                        // ËÆæÁΩÆÁºñËæëÂô®ÂÜÖÂÆπÔºàÂ∑≤Ëß£ÂØÜÔºâ
                        if (vditor) {
                            vditor.setValue(contentToRender);
                        }
                    } catch (error) {
                        console.error('Âä†ËΩΩÁ¨îËÆ∞Â§±Ë¥•:', error);
                        showToast(error.message || 'Âä†ËΩΩÁ¨îËÆ∞Â§±Ë¥•', 'error');
                        router.push('/');
                    }
                };

                // Ê∑ªÂä†Ê†áÁ≠æ
                const addTag = () => {
                    const tag = newTag.value.trim();
                    if (tag && !noteData.value.tags?.includes(tag)) {
                        if (!noteData.value.tags) {
                            noteData.value.tags = [];
                        }
                        noteData.value.tags.push(tag);
                        newTag.value = '';
                    }
                };

                // ÁßªÈô§Ê†áÁ≠æ
                const removeTag = (index) => {
                    if (noteData.value.tags) {
                        noteData.value.tags.splice(index, 1);
                        handleContentChange();
                    }
                };

                // ÂÜÖÂÆπÂèòÂåñÂ§ÑÁêÜ
                const handleContentChange = () => {
                    hasUnsavedChanges.value = true;
                };

                const getCoverUrl = (coverImg) => {
                if (typeof coverImg === 'string' && coverImg.startsWith('metafile://')) {
                    const pinId = coverImg.replace('metafile://', '');
                    return `https://man.metaid.io/content/${pinId}`;
                }
                return coverImg;
            };

                // Ëé∑ÂèñÈôÑ‰ª∂ URL
                const getAttachmentUrl = (attachment) => {
                    if (typeof attachment === 'string' && attachment.startsWith('metafile://')) {
                        const pinId = attachment.replace('metafile://', '');
                        return `https://man.metaid.io/content/${pinId}`;
                    }
                    return attachment;
                };

                // Âà§Êñ≠ÊòØÂê¶ÊòØÂõæÁâáÈôÑ‰ª∂
                const isImageAttachment = (attachment) => {
                    const url = getAttachmentUrl(attachment).toLowerCase();
                    return /\.(jpg|jpeg|png|gif|bmp|webp|svg)(\?|$)/i.test(url) ||
                           url.includes('image/');
                };

                // Âà§Êñ≠ÊòØÂê¶ÊòØËßÜÈ¢ëÈôÑ‰ª∂
                const isVideoAttachment = (attachment) => {
                    const url = getAttachmentUrl(attachment).toLowerCase();
                    return /\.(mp4|webm|ogg|mov|avi|mkv)(\?|$)/i.test(url) ||
                           url.includes('video/');
                };

                // Âà§Êñ≠ÊòØÂê¶ÊòØÈü≥È¢ëÈôÑ‰ª∂
                const isAudioAttachment = (attachment) => {
                    const url = getAttachmentUrl(attachment).toLowerCase();
                    return /\.(mp3|wav|ogg|m4a|aac|flac)(\?|$)/i.test(url) ||
                           url.includes('audio/');
                };

                // Ëé∑ÂèñÈôÑ‰ª∂Êñá‰ª∂Âêç
                const getAttachmentFileName = (attachment) => {
                    if (typeof attachment === 'string') {
                        // Â¶ÇÊûúÊòØ metafile:// Ê†ºÂºèÔºåÊèêÂèñ pinId ‰Ωú‰∏∫Êñá‰ª∂Âêç
                        if (attachment.startsWith('metafile://')) {
                            const pinId = attachment.replace('metafile://', '');
                            return `Êñá‰ª∂_${pinId.substring(0, 8)}`;
                        }
                        // Â∞ùËØï‰ªé URL ‰∏≠ÊèêÂèñÊñá‰ª∂Âêç
                        const parts = attachment.split('/');
                        const filename = parts[parts.length - 1];
                        // ÁßªÈô§Êü•ËØ¢ÂèÇÊï∞
                        return filename.split('?')[0] || attachment;
                    }
                    return 'ÈôÑ‰ª∂';
                };

                // Âà†Èô§Â∑≤ÊúâÈôÑ‰ª∂
                const deleteExistingAttachment = (index) => {
                    if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ÈôÑ‰ª∂ÂêóÔºü')) {
                        existingAttachments.value.splice(index, 1);
                        // ÂêåÊó∂‰ªénoteData.attachments‰∏≠Âà†Èô§
                        if (noteData.value.attachments) {
                            noteData.value.attachments.splice(index, 1);
                        }
                        showToast('ÈôÑ‰ª∂Â∑≤Âà†Èô§', 'success');
                        hasUnsavedChanges.value = true;
                    }
                };

                // Ëá™Âä®‰øùÂ≠òËçâÁ®ø
                const autoSaveDraft = async () => {
                    if (!hasUnsavedChanges.value) return;

                    const currentContent = JSON.stringify({
                        title: noteData.value.title,
                        subtitle: noteData.value.subtitle,
                        coverImg: coverImg.value,
                        content: noteData.value.content,
                        tags: noteData.value.tags || [],
                        encryption: privacySetting.value
                    });

                    if (currentContent === lastSavedContent.value) {
                        hasUnsavedChanges.value = false;
                        return;
                    }

                    try {
                        // ‰ΩøÁî®IndexedDB‰øùÂ≠òËçâÁ®ø
                        // Á°Æ‰øùÊâÄÊúâÊï∞ÊçÆÈÉΩÊòØÂèØÂ∫èÂàóÂåñÁöÑÁ∫ØÂØπË±°ÔºàÈÅøÂÖçDataCloneErrorÔºâ
                        const draftData = {
                            title: String(noteData.value.title || ''),
                            subtitle: String(noteData.value.subtitle || ''),
                            coverImg: String(coverImg.value || ''),
                            content: String(noteData.value.content || ''),
                            tags: Array.isArray(noteData.value.tags)
                                ? noteData.value.tags.map(tag => String(tag))
                                : [],
                            pinId: isEdit.value && pinId.value ? String(pinId.value) : ''
                        };

                        // Â¶ÇÊûúÂ∑≤ÊúâËçâÁ®øIDÔºåÊõ¥Êñ∞Áé∞ÊúâËçâÁ®øÔºõÂê¶ÂàôÂàõÂª∫Êñ∞ËçâÁ®ø
                        if (currentDraftId.value) {
                            draftData.id = currentDraftId.value;
                        } else if (isEdit.value && pinId.value) {
                            // ÁºñËæëÊ®°ÂºèÔºöÊü•ÊâæÊòØÂê¶Â∑≤ÊúâËØ•Á¨îËÆ∞ÁöÑËçâÁ®ø
                            const existingDraft = await draftDB.drafts.where('pinId').equals(pinId.value).first();
                            if (existingDraft) {
                                draftData.id = existingDraft.id;
                            }
                        }

                        const savedDraftId = await draftDB.saveDraft(draftData);
                        currentDraftId.value = savedDraftId;

                        // ‰øùÂ≠òÈôÑ‰ª∂Âà∞IndexedDB
                        if (attachments.value.length > 0) {
                            // ÂÖàÂà†Èô§ËØ•ËçâÁ®øÁöÑÊóßÈôÑ‰ª∂
                            const oldMedia = await draftDB.getMediaFilesByDraftId(savedDraftId);
                            for (const media of oldMedia) {
                                await draftDB.deleteMediaFile(media.id);
                            }

                            // ‰øùÂ≠òÊñ∞ÈôÑ‰ª∂
                            for (const attachment of attachments.value) {
                                try {
                                    await draftDB.saveMediaFile({
                                        draftId: savedDraftId,
                                        blobUrl: attachment.blobUrl,
                                        type: attachment.type,
                                        name: attachment.name,
                                        file: attachment.file,
                                        mediaId: attachment.id, // ‰øùÂ≠ò‰∏¥Êó∂mediaIdÁî®‰∫éÊÅ¢Â§ç
                                        pinId: isEdit.value && pinId.value ? String(pinId.value) : ''
                                    });
                                } catch (mediaError) {
                                    console.error('‰øùÂ≠òÈôÑ‰ª∂Â§±Ë¥•:', mediaError);
                                }
                            }
                            console.log(`Â∑≤‰øùÂ≠ò ${attachments.value.length} ‰∏™ÈôÑ‰ª∂Âà∞ËçâÁ®ø`);
                        }

                        lastSavedContent.value = currentContent;
                        hasUnsavedChanges.value = false;
                        console.log('ËçâÁ®øÂ∑≤Ëá™Âä®‰øùÂ≠òÂà∞IndexedDB, ID:', savedDraftId);
                    } catch (error) {
                        console.error('Ëá™Âä®‰øùÂ≠òËçâÁ®øÂ§±Ë¥•:', error);
                        console.error('ËçâÁ®øÊï∞ÊçÆ:', {
                            title: typeof noteData.value.title,
                            subtitle: typeof noteData.value.subtitle,
                            coverImg: typeof coverImg.value,
                            content: typeof noteData.value.content,
                            tags: Array.isArray(noteData.value.tags) ? 'array' : typeof noteData.value.tags,
                            tagsContent: noteData.value.tags
                        });
                    }
                };

                // ÂêØÂä®Ëá™Âä®‰øùÂ≠òÂÆöÊó∂Âô®
                const startAutoSave = () => {
                    autoSaveTimer.value = setInterval(() => {
                        autoSaveDraft();
                    }, 5000); // ÊØè5ÁßíËá™Âä®‰øùÂ≠ò‰∏ÄÊ¨°
                };

                // ÂÅúÊ≠¢Ëá™Âä®‰øùÂ≠òÂÆöÊó∂Âô®
                const stopAutoSave = () => {
                    if (autoSaveTimer.value) {
                        clearInterval(autoSaveTimer.value);
                        autoSaveTimer.value = null;
                    }
                };

                // Âä†ËΩΩËçâÁ®ø
                const loadDraft = async () => {
                    try {
                        let draftData = null;

                        // Ê£ÄÊü•ÊòØÂê¶‰ªéËçâÁ®øÁÆ±ÊâìÂºÄÁâπÂÆöËçâÁ®ø
                        const draftIdParam = router.currentRoute.value.query.draftId;
                        if (draftIdParam) {
                            // ‰ªéËçâÁ®øÁÆ±ÊâìÂºÄÔºöÂä†ËΩΩÊåáÂÆöÁöÑËçâÁ®ø
                            const draftId = parseInt(draftIdParam);
                            draftData = await draftDB.getDraft(draftId);
                            console.log('‰ªéËçâÁ®øÁÆ±Âä†ËΩΩËçâÁ®ø ID:', draftId);
                        } else if (isEdit.value && pinId.value) {
                            // ÁºñËæëÊ®°ÂºèÔºöÊü•ÊâæËØ•Á¨îËÆ∞ÁöÑËçâÁ®ø
                            draftData = await draftDB.drafts.where('pinId').equals(pinId.value).first();
                        } else {
                            // Êñ∞Âª∫Ê®°ÂºèÔºöËé∑ÂèñÊúÄÊñ∞ÁöÑÊ≤°ÊúâÂÖ≥ËÅîÁ¨îËÆ∞ÁöÑËçâÁ®ø
                            const drafts = await draftDB.drafts.where('pinId').equals('').reverse().sortBy('updatedAt');
                            draftData = drafts.length > 0 ? drafts[0] : null;
                        }

                        if (draftData) {
                            // Âè™Âú®ÂàõÂª∫Êñ∞Á¨îËÆ∞Êó∂Âä†ËΩΩËçâÁ®øÔºàÁºñËæëÊ®°Âºè‰ªéÊúçÂä°Âô®Âä†ËΩΩÔºâ
                            if (!isEdit.value) {
                                // Á°Æ‰øùÂä†ËΩΩÁöÑÊï∞ÊçÆÊòØÂπ≤ÂáÄÁöÑÔºàÈÅøÂÖçÊΩúÂú®ÁöÑÂ§çÊùÇÂØπË±°Ôºâ
                                noteData.value.title = String(draftData.title || '');
                                noteData.value.subtitle = String(draftData.subtitle || '');
                                noteData.value.content = String(draftData.content || '');
                                noteData.value.tags = Array.isArray(draftData.tags)
                                    ? draftData.tags.map(tag => String(tag))
                                    : [];
                                coverImg.value = String(draftData.coverImg || '');

                                // ËÆæÁΩÆÁºñËæëÂô®ÂÜÖÂÆπ
                                if (vditor && draftData.content) {
                                    vditor.setValue(String(draftData.content));
                                }

                                currentDraftId.value = draftData.id;

                                // ÊÅ¢Â§çÈôÑ‰ª∂
                                const savedMedia = await draftDB.getMediaFilesByDraftId(draftData.id);
                                if (savedMedia && savedMedia.length > 0) {
                                    // Ê∏ÖÁ©∫ÂΩìÂâçÈôÑ‰ª∂
                                    attachments.value = [];
                                    attachmentMap.value.clear();
                                    mediaUrlMap.value.clear();

                                    // ÊÅ¢Â§ç‰øùÂ≠òÁöÑÈôÑ‰ª∂
                                    for (const media of savedMedia) {
                                        const mediaId = media.mediaId || nextMediaId++;
                                        const mediaFileUrl = `metafile://${mediaId}`;

                                        // ÊÅ¢Â§çÂà∞ÈôÑ‰ª∂ÂàóË°®
                                        attachments.value.push({
                                            id: mediaId,
                                            blobUrl: media.blobUrl,
                                            file: media.file,
                                            type: media.type,
                                            name: media.name,
                                            createdAt: media.createdAt
                                        });

                                        // ÊÅ¢Â§çÊò†Â∞ÑÂÖ≥Á≥ª
                                        attachmentMap.value.set(mediaFileUrl, mediaId);
                                        mediaUrlMap.value.set(mediaFileUrl, media.blobUrl);

                                        // Êõ¥Êñ∞nextMediaId
                                        if (mediaId >= nextMediaId) {
                                            nextMediaId = mediaId + 1;
                                        }
                                    }
                                    console.log(`Â∑≤ÊÅ¢Â§ç ${savedMedia.length} ‰∏™ÈôÑ‰ª∂`);
                                }

                                lastSavedContent.value = JSON.stringify({
                                    title: draftData.title,
                                    subtitle: draftData.subtitle,
                                    coverImg: draftData.coverImg,
                                    content: draftData.content,
                                    tags: draftData.tags || []
                                });

                                console.log('Â∑≤‰ªéIndexedDBÂä†ËΩΩËçâÁ®ø, ID:', draftData.id);
                            } else {
                                // ÁºñËæëÊ®°ÂºèÔºöÂè™ËÆ∞ÂΩïËçâÁ®øIDÔºå‰∏çÂä†ËΩΩÂÜÖÂÆπÔºàÂÜÖÂÆπ‰ªéÊúçÂä°Âô®Âä†ËΩΩÔºâ
                                currentDraftId.value = draftData.id;
                            }
                        }
                    } catch (error) {
                        console.error('Âä†ËΩΩËçâÁ®øÂ§±Ë¥•:', error);
                    }
                };

                // Âà†Èô§ËçâÁ®ø
                const deleteDraft = async () => {
                    try {
                        if (currentDraftId.value) {
                            // Â¶ÇÊûúÊúâÂΩìÂâçËçâÁ®øIDÔºåÁõ¥Êé•Âà†Èô§
                            await draftDB.deleteDraft(currentDraftId.value);
                            console.log('ËçâÁ®øÂ∑≤‰ªéIndexedDBÂà†Èô§, ID:', currentDraftId.value);
                        } else if (isEdit.value && pinId.value) {
                            // ÁºñËæëÊ®°ÂºèÔºöÈÄöËøápinIdÂà†Èô§ËçâÁ®ø
                            await draftDB.deleteDraftByPinId(pinId.value);
                            console.log('ËçâÁ®øÂ∑≤ÈÄöËøápinIdÂà†Èô§:', pinId.value);
                        }

                        currentDraftId.value = null;
                        hasUnsavedChanges.value = false;
                    } catch (error) {
                        console.error('Âà†Èô§ËçâÁ®øÂ§±Ë¥•:', error);
                    }
                };

                // ‰øùÂ≠òÁ¨îËÆ∞
                const saveNote = async () => {
                    
                    if (!canSave.value || saving.value) return;
                    if (!userStore.isAuthorized) {
                        showToast('ËØ∑ÂÖàËøûÊé•Èí±ÂåÖ', 'warning');
                        return;
                    }

                    saving.value = true;

                    try {
                        // 1. Â§ÑÁêÜÈôÑ‰ª∂Ôºö‰∏ä‰º†Âπ∂ÊõøÊç¢ÂÜÖÂÆπ‰∏≠ÁöÑ URL
                        let processedContent = noteData.value.content;
                        const attachmentPinIds = [];

                        // 2. ‰∏ä‰º†Â∞ÅÈù¢ÂõæÁâáÔºàÂ¶ÇÊûúÊúâÊñ∞‰∏ä‰º†ÁöÑÂ∞ÅÈù¢Ôºâ
                        let finalCoverImg = noteData.value.coverImg || '';
                        if (coverFile.value) {
                            showToast('Ê≠£Âú®‰∏ä‰º†Â∞ÅÈù¢ÂõæÁâá...', 'info');
                            const coverPinId = await uploadFile(coverFile.value);
                            
                            finalCoverImg = `metafile://${coverPinId}`;
                            console.log('Â∞ÅÈù¢‰∏ä‰º†ÊàêÂäü:', finalCoverImg);
                        }

                        // 3. ‰∏ä‰º†ÈôÑ‰ª∂Âπ∂ÊõøÊç¢ÂÜÖÂÆπ‰∏≠ÁöÑ metafile URL
                        if (attachments.value.length > 0) {
                            showToast(`Ê≠£Âú®‰∏ä‰º† ${attachments.value.length} ‰∏™ÈôÑ‰ª∂...`, 'info');

                            for (const mediaFile of attachments.value) {
                                if (mediaFile.id && mediaFile.file) {
                                    // ÁîüÊàêÂéüÂßãÁöÑ metafile URL (‰∏¥Êó∂ID)
                                    const tempMediaFileUrl = `metafile://${mediaFile.id}`;

                                    // ‰∏ä‰º†ÈôÑ‰ª∂Âà∞Èìæ‰∏ä
                                    const pinId = await uploadFile(mediaFile.file);
                                    const actualMetafileUrl = `metafile://${pinId}`;

                                    // ‰øùÂ≠ò pinId Âà∞Êï∞ÁªÑ
                                    attachmentPinIds.push(actualMetafileUrl);

                                    // ÊõøÊç¢ÂÜÖÂÆπ‰∏≠ÁöÑ‰∏¥Êó∂ metafile://mediaId ‰∏∫ÂÆûÈôÖÁöÑ metafile://pinId
                                    processedContent = processedContent.replace(
                                        new RegExp(tempMediaFileUrl, 'g'),
                                        actualMetafileUrl
                                    );

                                    console.log('ÈôÑ‰ª∂‰∏ä‰º†ÊàêÂäü:', {
                                        original: tempMediaFileUrl,
                                        uploaded: actualMetafileUrl
                                    });
                                }
                            }
                        }

                        // 4. Â§ÑÁêÜÂä†ÂØÜÔºàÂ¶ÇÊûúÊòØÁßÅÂØÜÁ¨îËÆ∞Ôºâ
                        let encryption = '0';
                        if (privacySetting.value === 'aes') {
                            encryption = 'aes';

                            // Ëé∑ÂèñÁ≠æÂêçÂØÜÈí•
                            let sigKey = queryCurrentSigKey();

                            if (!sigKey) {
                                // Â¶ÇÊûúÊ≤°ÊúâÁ≠æÂêçÂØÜÈí•ÔºåÂÖàÁ≠æÂêç
                                sigKey = await signMessageAndStore();
                            }

                            if (sigKey) {
                                try {
                                    // Âä†ÂØÜÂÜÖÂÆπ
                                    processedContent = await encryptGCM(processedContent, sigKey);
                                } catch (error) {
                                    console.error('Âä†ÂØÜÂ§±Ë¥•:', error);
                                    showToast('Âä†ÂØÜÂ§±Ë¥•ÔºåÂ∞ÜÂèëÂ∏É‰∏∫ÂÖ¨ÂºÄÁ¨îËÆ∞', 'warning');
                                    encryption = '0';
                                }
                            } else {
                                showToast('Êó†Ê≥ïËé∑ÂèñÁ≠æÂêçÂØÜÈí•ÔºåÂ∞ÜÂèëÂ∏É‰∏∫ÂÖ¨ÂºÄÁ¨îËÆ∞', 'warning');
                                encryption = '0';
                            }
                        }

                        // 5. ÊûÑÂª∫ÊúÄÁªàÁöÑÁ¨îËÆ∞Êï∞ÊçÆ
                        const finalNoteData = {
                            ...noteData.value,
                            content: processedContent,
                            encryption: encryption,
                            coverImg: finalCoverImg,
                            createTime: noteData.value.createTime || Date.now(),
                            contentType: noteData.value.contentType || 'text/markdown',
                            attachments: attachmentPinIds  // Ê∑ªÂä†‰∏ä‰º†ÂêéÁöÑÈôÑ‰ª∂ pinId Êï∞ÁªÑ
                        };
                        

                        // 6. ‰øùÂ≠òÁ¨îËÆ∞Âà∞Èìæ‰∏ä
                        showToast('Ê≠£Âú®ÂèëÂ∏ÉÁ¨îËÆ∞...', 'info');
                        let result;
                        if (isEdit.value) {
                            // ÁºñËæëÊ®°ÂºèÔºöË∞ÉÁî® updateNote
                            result = await updateNote({
                                pinId: pinId.value,
                                noteData: finalNoteData,
                                attachments: [],  // attachments Â∑≤ÂåÖÂê´Âú® noteData ‰∏≠
                                options: {}
                            });
                        } else {
                            
                            // ÂàõÂª∫Ê®°ÂºèÔºöË∞ÉÁî® createNote
                            result = await createNote({
                                noteData: finalNoteData,
                                attachments: [],  // attachments Â∑≤ÂåÖÂê´Âú® noteData ‰∏≠
                                options: {}
                            });
                        }

                        if (result?.txid) {
                            showToast(isEdit.value ? 'Á¨îËÆ∞Êõ¥Êñ∞ÊàêÂäüÔºÅ' : 'Á¨îËÆ∞ÂàõÂª∫ÊàêÂäüÔºÅ', 'success');

                            // Âà†Èô§ËçâÁ®ø
                            await deleteDraft();

                            setTimeout(() => {
                                router.push('/');
                            }, 2000);
                        }
                    } catch (error) {
                        console.error('ÂèëÂ∏ÉÁ¨îËÆ∞Â§±Ë¥•:', error);
                        showToast(error.message || 'ÂèëÂ∏ÉÁ¨îËÆ∞Â§±Ë¥•', 'error');
                    } finally {
                        saving.value = false;
                    }
                };

                // ËøîÂõû
                const goBack = async () => {
                    if (hasUnsavedChanges.value) {
                        if (confirm('ÊúâÊú™‰øùÂ≠òÁöÑÊõ¥ÊîπÔºåÊòØÂê¶‰øùÂ≠ò‰∏∫ËçâÁ®øÔºü')) {
                            await autoSaveDraft();
                            showToast('ËçâÁ®øÂ∑≤‰øùÂ≠ò', 'success');
                        }
                    }
                    router.back();
                };

                // È°µÈù¢Á¶ªÂºÄÂâç‰øùÂ≠ò
                const handleBeforeUnload = async (e) => {
                    if (hasUnsavedChanges.value) {
                        await autoSaveDraft();
                        e.preventDefault();
                        e.returnValue = '';
                    }
                };

                onMounted(() => {
                    // ‰ΩøÁî® nextTick Á°Æ‰øù DOM Â∑≤Ê∏≤ÊüìÔºåÁÑ∂ÂêéÂàùÂßãÂåñÁºñËæëÂô®
                    nextTick(() => {
                        // Á≠âÂæÖ‰∏ÄÂ∞èÊÆµÊó∂Èó¥Á°Æ‰øù Vditor CDN ÂÆåÂÖ®Âä†ËΩΩ
                        setTimeout(() => {
                            initEditor();

                            // Â¶ÇÊûúÊòØÁºñËæëÊ®°ÂºèÔºåÂä†ËΩΩÁ¨îËÆ∞
                            if (isEdit.value) {
                                loadNote();
                            } else {
                                // // Â¶ÇÊûúÊòØÊñ∞Âª∫Ê®°ÂºèÔºåÂ∞ùËØïÂä†ËΩΩËçâÁ®ø
                                // loadDraft().catch(error => {
                                //     console.error('Âä†ËΩΩËçâÁ®øÊó∂Âá∫Èîô:', error);
                                // });
                            }

                            // ÂêØÂä®Ëá™Âä®‰øùÂ≠ò
                            startAutoSave();
                        }, 100);
                    });

                    // ÁõëÂê¨È°µÈù¢Á¶ªÂºÄ‰∫ã‰ª∂
                    window.addEventListener('beforeunload', handleBeforeUnload);
                });

                onBeforeUnmount(() => {
                    // ÂÅúÊ≠¢Ëá™Âä®‰øùÂ≠ò
                    stopAutoSave();

                    // Â¶ÇÊûúÊúâÊú™‰øùÂ≠òÁöÑÊõ¥ÊîπÔºå‰øùÂ≠òËçâÁ®øÔºàÂºÇÊ≠•‰ΩÜ‰∏çÈòªÂ°ûÂç∏ËΩΩÔºâ
                    if (hasUnsavedChanges.value) {
                        autoSaveDraft().catch(error => {
                            console.error('‰øùÂ≠òËçâÁ®øÊó∂Âá∫Èîô:', error);
                        });
                    }

                    // ÁßªÈô§È°µÈù¢Á¶ªÂºÄ‰∫ã‰ª∂ÁõëÂê¨
                    window.removeEventListener('beforeunload', handleBeforeUnload);

                    // ÈîÄÊØÅÁºñËæëÂô®ÂÆû‰æã
                    if (vditor) {
                        vditor.destroy();
                        vditor = null;
                    }
                });

                return {
                    isEdit,
                    noteData,
                    existingAttachments,
                    newTag,
                    saving,
                    canSave,
                    privacySetting,
                    coverImg,
                    coverInput,
                    attachments,
                    addTag,
                    removeTag,
                    saveNote,
                    goBack,
                    triggerCoverUpload,
                    handleCoverUpload,
                    removeCover,
                    getFileType,
                    getFileExtension,
                    formatFileSize,
                    handleDeleteAttachment,
                    handlePreviewAttachment,
                    getCoverUrl,
                    getAttachmentUrl,
                    isImageAttachment,
                    isVideoAttachment,
                    isAudioAttachment,
                    getAttachmentFileName,
                    deleteExistingAttachment
                };
            }
        };

        // NoteDetail - Á¨îËÆ∞ËØ¶ÊÉÖÁªÑ‰ª∂
        const NoteDetail = {
              components: {
               
                UserAvatar
            },
            template: `
                <div class="min-h-screen bg-base-200 pb-20">
                    <div class="container mx-auto px-4 py-6 max-w-4xl">
                        <!-- Â§¥ÈÉ® -->
                        <div class="flex items-center justify-between mb-6">
                            <button @click="goBack" class="btn btn-ghost gap-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                                </svg>
                                ËøîÂõû
                            </button>
                            <div class="flex gap-2">
                                <button @click="shareNote" class="btn btn-ghost btn-sm gap-2" title="ÂàÜ‰∫´Á¨îËÆ∞">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"/>
                                    </svg>
                                    ÂàÜ‰∫´
                                </button>
                                <button v-if="isOwner" @click="goToEdit" class="btn btn-outline btn-primary btn-sm">ÁºñËæë</button>
                            </div>
                        </div>

                        <!-- Âä†ËΩΩÁä∂ÊÄÅ -->
                        <div v-if="loading" class="flex flex-col items-center justify-center py-20">
                            <span class="loading loading-spinner loading-lg"></span>
                            <p class="mt-4 text-base-content/60">Âä†ËΩΩ‰∏≠...</p>
                        </div>

                        <!-- Á¨îËÆ∞ÂÜÖÂÆπ -->
                        <div v-else-if="noteData" class="card bg-base-100 shadow-xl mx-auto">
                            <div class="card-body">
                                <!-- Ê†áÈ¢ò -->
                                <div class="flex items-start gap-3 mb-2">
                                    <h1 class="text-3xl font-bold">{{ noteData.title }}</h1>
                                    <span v-if="isNoteEncrypted" class="badge badge-warning">Private</span>
                                </div>

                                <!-- ÂâØÊ†áÈ¢ò -->
                                <p v-if="noteData.subtitle" class="text-lg text-base-content/70 mb-4">
                                    {{ noteData.subtitle }}
                                </p>

                                <!-- ‰ΩúËÄÖ‰ø°ÊÅØ -->
                                <div v-if="userInfo" class="flex items-center gap-3 mb-4 pb-4 border-b border-base-300">
                                    <div class="avatar">
                                        <div class="rounded-full ">
                                           
                                           
                                        <UserAvatar
                                            v-if="userInfo.avatar"
                                            :image="userInfo.avatar"
                                            :meta-id="userInfo.metaid"
                                            :name="userInfo.name"
                                           
                                        />
                                        </div>
                                    </div>
                                    <div class="flex-1">
                                        <p class="font-medium text-sm">{{ userInfo.name || userInfo.metaid.slice(0,6) }}</p>
                                       
                                    </div>
                                </div>

                                <!-- Â∞ÅÈù¢ÂõæÁâá -->
                                <div v-if="noteData.coverImg" class="mb-6">
                                    <img :src="getCoverUrl(noteData.coverImg)"
                                         alt="Cover"
                                         class="w-full rounded-lg shadow-md object-cover"
                                         style="max-height: 400px;" />
                                </div>

                                <!-- ÂÖÉ‰ø°ÊÅØ -->
                                <div class="flex flex-wrap gap-4 py-4 border-y border-base-300 mb-6">
                                    <span class="flex items-center gap-2 text-sm text-base-content/60">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                        </svg>
                                        {{ formatTime(pin.timestamp) }}
                                    </span>
                                    <span v-if="noteData.tags && noteData.tags.length > 0"
                                          class="flex items-center gap-2 text-sm text-base-content/60">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"/>
                                        </svg>
                                        {{ noteData.tags.length }} ‰∏™Ê†áÁ≠æ
                                    </span>
                                    <span v-if="noteData.attachments && noteData.attachments.length > 0"
                                          class="flex items-center gap-2 text-sm text-base-content/60">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"/>
                                        </svg>
                                        {{ noteData.attachments.length }} ‰∏™ÈôÑ‰ª∂
                                    </span>
                                </div>

                                <!-- Ê†áÁ≠æ -->
                                <div v-if="noteData.tags && noteData.tags.length > 0" class="flex flex-wrap gap-2 mb-6">
                                    <span v-for="tag in noteData.tags"
                                          :key="tag"
                                          class="badge badge-primary">
                                        {{ tag }}
                                    </span>
                                </div>

                                <!-- ÂÜÖÂÆπ -->
                                <div class="prose max-w-none mb-6">
                                    <div v-html="formatMarkdown(noteData.content)"></div>
                                </div>

                                <!-- ÈôÑ‰ª∂ÂàóË°® -->
                                <div v-if="noteData.attachments && noteData.attachments.length > 0"
                                     class="border-t border-base-300 pt-6 mt-6">
                                    <h3 class="text-xl font-semibold mb-4">ÈôÑ‰ª∂ ({{ noteData.attachments.length }})</h3>
                                    <div class="attachments-list grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div v-for="(attachment, index) in noteData.attachments"
                                             :key="index"
                                             class="attachment-item border border-base-300 rounded-lg overflow-hidden bg-base-100">
                                            <!-- ÂõæÁâáÈ¢ÑËßà -->
                                            <div v-if="isImageAttachment(attachment)"
                                                 class="relative group cursor-pointer"
                                                 @click="openAttachment(attachment)">
                                                <img :src="getAttachmentUrl(attachment)"
                                                     :alt="'ÈôÑ‰ª∂' + (index + 1)"
                                                     class="w-full h-48 object-cover hover:opacity-90 transition-opacity"
                                                     @error="handleAttachmentError($event, attachment, index)"/>
                                                <div class="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-20 transition-all flex items-center justify-center">
                                                    <svg class="w-12 h-12 text-white opacity-0 group-hover:opacity-100 transition-opacity" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"/>
                                                    </svg>
                                                </div>
                                                <div class="absolute bottom-0 left-0 right-0 bg-black bg-opacity-50 text-white text-xs p-2">
                                                    <p class="truncate">ÂõæÁâáÈôÑ‰ª∂</p>
                                                </div>
                                            </div>

                                            <!-- ËßÜÈ¢ëÈ¢ÑËßà -->
                                            <div v-else-if="isVideoAttachment(attachment)"
                                                 class="relative">
                                                <video :src="getAttachmentUrl(attachment)"
                                                       controls
                                                       class="w-full h-48 object-cover bg-black"
                                                       @error="handleAttachmentError($event, attachment, index)">
                                                    ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅËßÜÈ¢ëÊí≠Êîæ
                                                </video>
                                                <button @click="openAttachment(attachment)"
                                                        class="absolute top-2 right-2 btn btn-xs btn-primary">
                                                    Âú®Êñ∞Á™óÂè£ÊâìÂºÄ
                                                </button>
                                            </div>

                                            <!-- Èü≥È¢ëÈ¢ÑËßà -->
                                            <div v-else-if="isAudioAttachment(attachment)"
                                                 class="p-4">
                                                <div class="flex items-center gap-3 mb-3">
                                                    <svg class="w-10 h-10 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"/>
                                                    </svg>
                                                    <div class="flex-1">
                                                        <p class="font-medium text-sm">Èü≥È¢ëÊñá‰ª∂</p>
                                                        <p class="text-xs text-base-content/60 break-all">{{ getAttachmentFileName(attachment) }}</p>
                                                    </div>
                                                </div>
                                                <audio :src="getAttachmentUrl(attachment)"
                                                       controls
                                                       class="w-full"
                                                       @error="handleAttachmentError($event, attachment, index)">
                                                </audio>
                                                <button @click="openAttachment(attachment)"
                                                        class="btn btn-primary btn-sm btn-block mt-3">
                                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                                                    </svg>
                                                    ‰∏ãËΩΩ
                                                </button>
                                            </div>

                                            <!-- ÂÖ∂‰ªñÊñá‰ª∂Á±ªÂûã -->
                                            <div v-else class="p-4">
                                                <div class="flex items-start gap-3">
                                                    <div class="flex-shrink-0">
                                                        <svg class="w-10 h-10 text-base-content/60" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                                                        </svg>
                                                    </div>
                                                    <div class="flex-1  min-w-0">
                                                        <p class="font-medium text-sm mb-1">{{ getAttachmentFileName(attachment) }}</p>
                                                      
                                                        
                                                    </div>
                                                </div>
                                                <button @click="openAttachment(attachment)"
                                                        class="btn btn-primary btn-sm btn-block !mt-3">
                                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                                                    </svg>
                                                    <span >‰∏ãËΩΩ</span>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- ÈîôËØØÁä∂ÊÄÅ -->
                        <div v-else class="text-center py-20">
                            <p class="text-lg text-base-content/60 mb-4">Âä†ËΩΩÁ¨îËÆ∞Â§±Ë¥•</p>
                            <button @click="loadNote" class="btn btn-primary">ÈáçËØï</button>
                        </div>
                    </div>
                </div>
            `,
            setup() {
                const userStore = useUserStore();
                const { showToast } = useToast();

                const pinId = computed(() => router.currentRoute.value.params.id);

                const loading = ref(false);
                const deleting = ref(false);
                const pin = ref(null);
                const noteData = ref(null);
                const userInfo = ref(null); // Á¨îËÆ∞‰ΩúËÄÖ‰ø°ÊÅØ
                const attachmentMimeTypes = ref({});

                const isOwner = computed(() => {
                    return pin.value && userStore.last?.address === pin.value.address;
                });

                // Âà§Êñ≠Á¨îËÆ∞ÊòØÂê¶Âä†ÂØÜ
                const isNoteEncrypted = computed(() => {
                    if (!noteData.value?.encryption) return false;
                    return noteData.value.encryption !== '0';
                });

                // Ëß£ÂØÜÁ¨îËÆ∞ÂÜÖÂÆπ
                const decryptNoteContent = async (encryptedContent) => {
                    try {
                        // Âà§Êñ≠ÊòØÂê¶ÊòØËá™Â∑±ÁöÑÁ¨îËÆ∞
                        if (!isOwner.value) {
                            // Âà´‰∫∫ÁöÑÁ¨îËÆ∞ÔºåÊó†Ê≥ïËß£ÂØÜ
                            return 'Ê≠§Á¨îËÆ∞ÂÜÖÂÆπÂ∑≤Âä†ÂØÜ';
                        }

                        // Ëé∑ÂèñÁ≠æÂêçÂØÜÈí•
                        let sigKey = queryCurrentSigKey();
                        if (!sigKey) {
                            // Â¶ÇÊûúÊ≤°ÊúâÁ≠æÂêçÂØÜÈí•ÔºåÂÖàÁ≠æÂêç
                            sigKey = await signMessageAndStore();
                        }

                        if (!sigKey) {
                            return 'Êó†Ê≥ïËé∑ÂèñËß£ÂØÜÂØÜÈí•';
                        }

                        // Ëß£ÂØÜÂÜÖÂÆπ
                        const decryptedContent = await decryptGCM(encryptedContent, sigKey);
                        return decryptedContent;
                    } catch (error) {
                        console.error('Ëß£ÂØÜÂ§±Ë¥•:', error);
                        return 'Ëß£ÂØÜÂ§±Ë¥•ÔºåÊó†Ê≥ïÊòæÁ§∫ÂÜÖÂÆπ';
                    }
                };

                // Âä†ËΩΩÁ¨îËÆ∞ËØ¶ÊÉÖ
                const loadNote = async () => {
                    if (!pinId.value) return;

                    loading.value = true;
                    try {
                        const result = await getNoteDetail(pinId.value);
                        pin.value = result.pin;
                        noteData.value = result.noteData;

                        // Ëé∑ÂèñÁ¨îËÆ∞‰ΩúËÄÖ‰ø°ÊÅØ
                        if (pin.value && pin.value.address) {
                            try {
                                userInfo.value = await getUserInfoByAddress(pin.value.address);
                                console.log('‰ΩúËÄÖ‰ø°ÊÅØ:', userInfo.value);
                            } catch (error) {
                                console.error('Ëé∑Âèñ‰ΩúËÄÖ‰ø°ÊÅØÂ§±Ë¥•:', error);
                            }
                        }

                        // Ê£ÄÊü•Á¨îËÆ∞ÊòØÂê¶Âä†ÂØÜ
                        if (noteData.value.encryption && noteData.value.encryption !== '0') {
                            // Á¨îËÆ∞Â∑≤Âä†ÂØÜÔºåÈúÄË¶ÅËß£ÂØÜ
                            const decryptedContent = await decryptNoteContent(noteData.value.content);
                            noteData.value.content = decryptedContent;
                        }

                        // Ëé∑ÂèñÈôÑ‰ª∂ÁöÑMIMEÁ±ªÂûãÔºàÂºÇÊ≠•Ôºå‰∏çÈòªÂ°ûÈ°µÈù¢ÊòæÁ§∫Ôºâ
                        if (noteData.value.attachments && noteData.value.attachments.length > 0) {
                            noteData.value.attachments.forEach((attachment, index) => {
                                // Âè™ÂØπÈùûÂõæÁâá„ÄÅÈùûËßÜÈ¢ë„ÄÅÈùûÈü≥È¢ëÁöÑÈôÑ‰ª∂Ëé∑ÂèñMIMEÁ±ªÂûã
                                if (!isImageAttachment(attachment) &&
                                    !isVideoAttachment(attachment) &&
                                    !isAudioAttachment(attachment)) {
                                    fetchAttachmentMimeType(attachment, index);
                                }
                            });
                        }
                    } catch (error) {
                        console.error('Âä†ËΩΩÁ¨îËÆ∞ËØ¶ÊÉÖÂ§±Ë¥•:', error);
                        showToast(error.message || 'Âä†ËΩΩÁ¨îËÆ∞ËØ¶ÊÉÖÂ§±Ë¥•', 'error');
                    } finally {
                        loading.value = false;
                    }
                };

                // Ê†ºÂºèÂåñÊó∂Èó¥
                const formatTime = (timestamp) => {
                    const date = new Date(timestamp * 1000);
                    return date.toLocaleString('zh-CN', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                };

                // Ëé∑ÂèñÂ∞ÅÈù¢ÂõæÁâá URL
                const getCoverUrl = (coverImg) => {
                    if (typeof coverImg === 'string' && coverImg.startsWith('metafile://')) {
                        const pinId = coverImg.replace('metafile://', '');
                        return `https://man.metaid.io/content/${pinId}`;
                    }
                    return coverImg;
                };

                // Ëé∑ÂèñÈôÑ‰ª∂ URL
                const getAttachmentUrl = (attachment) => {
                    if (typeof attachment === 'string' && attachment.startsWith('metafile://')) {
                        const pinId = attachment.replace('metafile://', '');
                        return `https://man.metaid.io/content/${pinId}`;
                    }
                    return attachment;
                };

                // Ê†ºÂºèÂåñ Markdown
                const formatMarkdown = (content) => {
                    if (!content) return '';

                    let processedContent = content;

                    // ÊõøÊç¢ÈôÑ‰ª∂Âç†‰ΩçÁ¨¶ÔºàÂ¶ÇÊûúÊúâÔºâ
                    if (noteData.value.attachments && noteData.value.attachments.length > 0) {
                        noteData.value.attachments.forEach((attachment, index) => {
                            const attachmentUrl = getAttachmentUrl(attachment);
                            // ÊõøÊç¢ {{attachment-0}}, {{attachment-1}} Á≠âÂç†‰ΩçÁ¨¶
                            processedContent = processedContent.replace(`{{attachment-${index}}}`, attachmentUrl);
                        });
                    }

                    // ÊõøÊç¢ÂÜÖÂÆπ‰∏≠ÁöÑ metafile:// URLÔºàÁî®‰∫émarkdown‰∏≠ÁöÑÂõæÁâáÁ≠âÔºâ
                    processedContent = processedContent.replace(/metafile:\/\/([a-zA-Z0-9]+)/g, (match, pinId) => {
                        return `https://man.metaid.io/content/${pinId}`;
                    });

                    // ‰ΩøÁî® marked Â∫ìÊ∏≤Êüì Markdown
                    if (typeof marked !== 'undefined') {
                        try {
                            // ÈÖçÁΩÆ marked ÈÄâÈ°π
                            const markedOptions = {
                                breaks: true,        // ÊîØÊåÅ GitHub È£éÊ†ºÁöÑÊç¢Ë°å
                                gfm: true,          // ÂêØÁî® GitHub Flavored Markdown
                                headerIds: true,    // ‰∏∫Ê†áÈ¢òÁîüÊàê ID
                                mangle: false,      // ‰∏çÊ∑∑Ê∑ÜÈÇÆÁÆ±Âú∞ÂùÄ
                                pedantic: false     // ‰∏ç‰ΩøÁî®‰∏•Ê†ºÊ®°Âºè
                            };

                            // Ê∏≤Êüì markdown (marked.parse ÊîØÊåÅ‰º†ÂÖ• options)
                            let rendered = '';
                            if (typeof marked.parse === 'function') {
                                rendered = marked.parse(processedContent, markedOptions);
                            } else if (typeof marked === 'function') {
                                // ÊóßÁâàÊú¨ API
                                rendered = marked(processedContent, markedOptions);
                            }

                            if (rendered) {
                                console.log('Markdown rendered successfully:', rendered.substring(0, 100) + '...');
                                return rendered;
                            }
                        } catch (error) {
                            console.error('Marked rendering error:', error);
                            console.log('Falling back to simple replacement');
                        }
                    } else {
                        console.warn('marked library not available, using fallback');
                    }

                    // Â¶ÇÊûú marked Â∫ì‰∏çÂèØÁî®Ôºå‰ΩøÁî®ÁÆÄÂçïÁöÑÊõøÊç¢‰Ωú‰∏∫ÈôçÁ∫ßÊñπÊ°à
                    return processedContent
                        .replace(/^### (.*$)/gim, '<h3 class="text-xl font-semibold mt-4 mb-2">$1</h3>')
                        .replace(/^## (.*$)/gim, '<h2 class="text-2xl font-bold mt-6 mb-3">$1</h2>')
                        .replace(/^# (.*$)/gim, '<h1 class="text-3xl font-bold mt-8 mb-4">$1</h1>')
                        .replace(/\*\*(.*?)\*\*/gim, '<strong class="font-semibold">$1</strong>')
                        .replace(/\*(.*?)\*/gim, '<em class="italic">$1</em>')
                        .replace(/`(.*?)`/gim, '<code class="bg-base-200 px-2 py-1 rounded text-sm font-mono">$1</code>')
                        .replace(/\n/gim, '<br>');
                };

                // Âà§Êñ≠ÊòØÂê¶ÊòØÂõæÁâáÈôÑ‰ª∂
                const isImageAttachment = (attachment) => {
                    const url = getAttachmentUrl(attachment).toLowerCase();
                    return /\.(jpg|jpeg|png|gif|bmp|webp|svg)(\?|$)/i.test(url) ||
                           url.includes('image/');
                };

                // Âà§Êñ≠ÊòØÂê¶ÊòØËßÜÈ¢ëÈôÑ‰ª∂
                const isVideoAttachment = (attachment) => {
                    const url = getAttachmentUrl(attachment).toLowerCase();
                    return /\.(mp4|webm|ogg|mov|avi|mkv)(\?|$)/i.test(url) ||
                           url.includes('video/');
                };

                // Âà§Êñ≠ÊòØÂê¶ÊòØÈü≥È¢ëÈôÑ‰ª∂
                const isAudioAttachment = (attachment) => {
                    const url = getAttachmentUrl(attachment).toLowerCase();
                    return /\.(mp3|wav|ogg|m4a|aac|flac)(\?|$)/i.test(url) ||
                           url.includes('audio/');
                };

                // Ëé∑ÂèñÈôÑ‰ª∂Êñá‰ª∂Âêç
                const getAttachmentFileName = (attachment) => {
                    if (typeof attachment === 'string') {
                        // Â¶ÇÊûúÊòØ metafile:// Ê†ºÂºèÔºåÊèêÂèñ pinId ‰Ωú‰∏∫Êñá‰ª∂Âêç
                        if (attachment.startsWith('metafile://')) {
                            const pinId = attachment.replace('metafile://', '');
                            return `Êñá‰ª∂_${pinId.substring(0, 8)}`;
                        }
                        // Â∞ùËØï‰ªé URL ‰∏≠ÊèêÂèñÊñá‰ª∂Âêç
                        const parts = attachment.split('/');
                        const filename = parts[parts.length - 1];
                        // ÁßªÈô§Êü•ËØ¢ÂèÇÊï∞
                        return filename.split('?')[0] || attachment;
                    }
                    return 'ÈôÑ‰ª∂';
                };

                // Ëé∑ÂèñÊñá‰ª∂Êâ©Â±ïÂêç
                const getFileExtension = (attachment) => {
                    const filename = getAttachmentFileName(attachment);
                    const parts = filename.split('.');
                    if (parts.length > 1) {
                        return parts[parts.length - 1].toUpperCase();
                    }
                    return '';
                };

                // Â§ÑÁêÜÈôÑ‰ª∂Âä†ËΩΩÈîôËØØ
                const handleAttachmentError = async (event, attachment, index) => {
                    console.error('ÈôÑ‰ª∂Âä†ËΩΩÂ§±Ë¥•:', attachment);
                    // ÂèØ‰ª•Â∞ùËØïËé∑Âèñ MIME Á±ªÂûã
                    try {
                        const url = getAttachmentUrl(attachment);
                        const response = await fetch(url, { method: 'HEAD' });
                        const contentType = response.headers.get('content-type');
                        if (contentType) {
                            attachmentMimeTypes.value[index] = contentType;
                        }
                    } catch (error) {
                        console.error('Ëé∑ÂèñMIMEÁ±ªÂûãÂ§±Ë¥•:', error);
                    }
                };

                // ÊâìÂºÄÈôÑ‰ª∂ÔºàÂú®Êñ∞Á™óÂè£‰∏≠ÊâìÂºÄÔºâ
                const openAttachment = (attachment) => {
                    const url = getAttachmentUrl(attachment);
                    window.open(url, '_blank');
                };

                // Ëé∑ÂèñÈôÑ‰ª∂ÁöÑMIMEÁ±ªÂûã
                const fetchAttachmentMimeType = async (attachment, index) => {
                    try {
                        const url = getAttachmentUrl(attachment);
                        const response = await fetch(url, { method: 'HEAD' });
                        const contentType = response.headers.get('content-type');
                        if (contentType) {
                            attachmentMimeTypes.value[index] = contentType;
                        }
                    } catch (error) {
                        console.error('Ëé∑ÂèñMIMEÁ±ªÂûãÂ§±Ë¥•:', error);
                    }
                };

                // ‰∏ãËΩΩÈôÑ‰ª∂ÔºàÂ∑≤Ë¢´ openAttachment Êõø‰ª£Ôºå‰øùÁïôÁî®‰∫éÂêëÂêéÂÖºÂÆπÔºâ
                const downloadAttachment = (attachment) => {
                    openAttachment(attachment);
                };

                // Ë∑≥ËΩ¨Âà∞ÁºñËæëÈ°µÈù¢
                const goToEdit = () => {
                    router.push(`/note/${pinId.value}/edit`);
                };

                // Âà†Èô§Á¨îËÆ∞
                // const handleDelete = async () => {
                //     if (!pinId.value || !isOwner.value) return;

                //     if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÁØáÁ¨îËÆ∞ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ')) {
                //         return;
                //     }

                //     deleting.value = true;
                //     try {
                //         const result = await deleteNote(pinId.value, {});

                //         if (result?.txid) {
                //             showToast('Á¨îËÆ∞Âà†Èô§ÊàêÂäüÔºÅ', 'success');
                //             setTimeout(() => {
                //                 router.push('/');
                //             }, 1500);
                //         }
                //     } catch (error) {
                //         console.error('Âà†Èô§Á¨îËÆ∞Â§±Ë¥•:', error);
                //         showToast(error.message || 'Âà†Èô§Á¨îËÆ∞Â§±Ë¥•', 'error');
                //     } finally {
                //         deleting.value = false;
                //     }
                // };

                // ËøîÂõû
                const goBack = () => {
                    router.back();
                };

                // ÂàÜ‰∫´Á¨îËÆ∞ - Â§çÂà∂ÂΩìÂâçÈ°µÈù¢Ë∑ØÁî±
                const shareNote = async () => {
                    try {
                        const currentUrl = window.location.href;
                        await navigator.clipboard.writeText(currentUrl);
                        showToast('ÈìæÊé•Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø', 'success');
                    } catch (error) {
                        console.error('Â§çÂà∂ÈìæÊé•Â§±Ë¥•:', error);
                        // ÈôçÁ∫ßÊñπÊ°àÔºö‰ΩøÁî®‰º†ÁªüÊñπÊ≥ï
                        try {
                            const textarea = document.createElement('textarea');
                            textarea.value = window.location.href;
                            textarea.style.position = 'fixed';
                            textarea.style.opacity = '0';
                            document.body.appendChild(textarea);
                            textarea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textarea);
                            showToast('ÈìæÊé•Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø', 'success');
                        } catch (fallbackError) {
                            showToast('Â§çÂà∂Â§±Ë¥•ÔºåËØ∑ÊâãÂä®Â§çÂà∂ÈìæÊé•', 'error');
                        }
                    }
                };

                onMounted(() => {
                    loadNote();
                });

                return {
                    loading,
                    deleting,
                    pin,
                    noteData,
                    userInfo,
                    attachmentMimeTypes,
                    isOwner,
                    isNoteEncrypted,
                    loadNote,
                    formatTime,
                    formatMarkdown,
                    getCoverUrl,
                    getAttachmentUrl,
                    isImageAttachment,
                    isVideoAttachment,
                    isAudioAttachment,
                    getAttachmentFileName,
                    getFileExtension,
                    handleAttachmentError,
                    openAttachment,
                    downloadAttachment,
                    goToEdit,
                    goBack,
                    shareNote
                };
            }
        };

        // Draft - ËçâÁ®øÁÆ±ÁªÑ‰ª∂
        const Draft = {
            components: {
              
            },
            template: `
                <div class="min-h-screen bg-base-200">
                    <!-- Â§¥ÈÉ® -->
                    <div class="bg-base-100 shadow-sm">
                        <div class="container mx-auto px-4 py-4">
                            <div class="flex items-center justify-between">
                                <h1 class="text-2xl font-bold">Draft Box</h1>
                                <div class="flex items-center gap-2">
                                    <button @click="goBack" class="btn btn-outline btn-sm">ËøîÂõû</button>
                                   
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ÂÜÖÂÆπ -->
                    <main class="container mx-auto px-4 py-8">
                        <!-- Âä†ËΩΩ‰∏≠ -->
                        <div v-if="loading" class="text-center py-20">
                            <div class="loading loading-spinner loading-lg"></div>
                            <p class="mt-4 text-gray-500">Âä†ËΩΩ‰∏≠...</p>
                        </div>

                        <!-- ËçâÁ®øÂàóË°® -->
                        <div v-else-if="drafts.length > 0" class="space-y-4 flex flex-col items-center">
                            <div
                                v-for="draft in drafts"
                                :key="draft.id"
                                class="card bg-base-100 shadow hover:shadow-xl transition-shadow w-full"
                            >
                                <div class="card-body cursor-pointer" @click="editDraft(draft.id)">
                                    <div class="flex justify-between gap-4">
                                        <div class="flex-1">
                                            <h3 class="card-title">{{ draft.title || 'Êó†Ê†áÈ¢ò' }}</h3>
                                            <p v-if="draft.subtitle" class="text-base-content/70 mt-2">{{ draft.subtitle }}</p>
                                            <div class="flex items-center gap-4 mt-3 text-sm text-base-content/60">
                                                <span>ÊúÄÂêéÁºñËæë: {{ formatDate(draft.updatedAt) }}</span>
                                                <span v-if="draft.tags && draft.tags.length > 0" class="text-primary">
                                                    Ê†áÁ≠æ: {{ draft.tags.join(', ') }}
                                                </span>
                                            </div>
                                        </div>
                                        <div v-if="draft.coverImg" class="flex-shrink-0">
                                            <img :src="draft.coverImg" alt="cover" class="w-32 h-24 object-cover rounded-lg" />
                                        </div>
                                    </div>
                                    <div class="card-actions justify-end mt-4 pt-4 border-t">
                                        <button @click.stop="editDraft(draft.id)" class="btn btn-sm btn-primary">ÁºñËæë</button>
                                        <button @click.stop="confirmDelete(draft.id)" class="btn btn-sm btn-error">Âà†Èô§</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Á©∫Áä∂ÊÄÅ -->
                        <div v-else class="text-center py-20">
                            <svg class="w-24 h-24 mx-auto text-base-300 mb-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                            </svg>
                            <p class="text-xl text-base-content/60 mb-4">ËøòÊ≤°ÊúâËçâÁ®ø</p>
                            <button @click="goToCreate" class="btn btn-primary">ÂºÄÂßãÂÜô‰Ωú</button>
                        </div>
                    </main>
                </div>
            `,
            setup() {
                const drafts = ref([]);
                const loading = ref(false);
                const { showToast } = useToast();

                // Ê†ºÂºèÂåñÊó•Êúü
                const formatDate = (timestamp) => {
                    const date = new Date(timestamp);
                    return date.toLocaleString('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                };

                // Âä†ËΩΩËçâÁ®øÂàóË°®
                const loadDrafts = async () => {
                    loading.value = true;
                    try {
                        drafts.value = await draftDB.getAllDrafts();
                    } catch (error) {
                        console.error('Failed to load drafts:', error);
                        showToast('Âä†ËΩΩËçâÁ®øÂ§±Ë¥•', 'error');
                    } finally {
                        loading.value = false;
                    }
                };

                // ÁºñËæëËçâÁ®ø
                const editDraft = (draftId) => {
                    router.push({
                        path: '/note/new',
                        query: { draftId: draftId.toString() }
                    });
                };

                // Á°ÆËÆ§Âà†Èô§
                const confirmDelete = async (draftId) => {
                    if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÁØáËçâÁ®øÂêóÔºü')) {
                        await deleteDraft(draftId);
                    }
                };

                // Âà†Èô§ËçâÁ®ø
                const deleteDraft = async (draftId) => {
                    try {
                        await draftDB.deleteDraft(draftId);
                        showToast('ËçâÁ®øÂ∑≤Âà†Èô§', 'success');
                        await loadDrafts();
                    } catch (error) {
                        console.error('Failed to delete draft:', error);
                        showToast('Âà†Èô§ËçâÁ®øÂ§±Ë¥•', 'error');
                    }
                };

                // ËøîÂõûÈ¶ñÈ°µ
                const goBack = () => {
                    router.push('/');
                };

                // Êñ∞Âª∫Á¨îËÆ∞
                const goToCreate = () => {
                    router.push('/note/new');
                };

                onMounted(() => {
                    loadDrafts();
                });

                return {
                    drafts,
                    loading,
                    formatDate,
                    editDraft,
                    confirmDelete,
                    goBack,
                    goToCreate
                };
            }
        };

        // MyNote - ÊàëÁöÑÁ¨îËÆ∞ÁªÑ‰ª∂
        const MyNote = {
            components: {
               
                UserAvatar
            },
            template: `
                <div class="min-h-screen bg-base-200">
                    <!-- Â§¥ÈÉ® -->
                    <div class="bg-base-100 shadow-sm">
                        <div class="container mx-auto px-4 py-4">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h1 class="text-2xl font-bold">ÊàëÁöÑÁ¨îËÆ∞</h1>
                                    <p class="text-sm text-base-content/60">ÁÆ°ÁêÜÊÇ®ÁöÑ‰∏™‰∫∫Á¨îËÆ∞</p>
                                </div>
                                <div class="flex items-center gap-2">
                                    <button @click="goBack" class="btn btn-outline btn-sm">ËøîÂõû</button>
                                  
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ÂÜÖÂÆπ -->
                    <main class="container mx-auto px-4 py-8">
                        <!-- Êú™ÁôªÂΩïÊèêÁ§∫ -->
                        <div v-if="!isAuthorized" class="text-center py-20">
                            <svg class="w-24 h-24 mx-auto text-base-300 mb-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
                            </svg>
                            <h2 class="text-2xl font-bold mb-2">ËØ∑ÂÖàËøûÊé•Èí±ÂåÖ</h2>
                            <p class="text-base-content/60">ËøûÊé•Èí±ÂåÖÂêéÂç≥ÂèØÊü•ÁúãÊÇ®ÁöÑÁ¨îËÆ∞</p>
                        </div>

                        <!-- Âä†ËΩΩ‰∏≠ -->
                        <div v-else-if="loading" class="text-center py-20">
                            <div class="loading loading-spinner loading-lg"></div>
                            <p class="mt-4 text-gray-500">Âä†ËΩΩ‰∏≠...</p>
                        </div>

                        <!-- Á¨îËÆ∞ÂàóË°® -->
                        <div v-else-if="notes.length > 0" class="space-y-4 flex flex-col items-center">
                            <div
                                v-for="note in notes"
                                :key="note.id"
                                @click="viewNote(note.id)"
                                class="card bg-base-100 shadow hover:shadow-xl transition-all cursor-pointer w-full"
                            >
                                <div class="card-body">
                                    <div class="flex justify-between gap-4">
                                        <div class="flex-1">
                                            <div class="flex items-start gap-2">
                                                <h3 class="card-title">{{ getNoteTitle(note) }}</h3>
                                                <span v-if="getNoteIsEncrypt(note)" class="badge badge-sm  badge-warning">Private</span>
                                            </div>
                                        </div>
                                        <div v-if="getNoteCover(note)" class="flex-shrink-0">
                                            <img :src="getNoteCover(note)" alt="cover" class="w-32 h-24 object-cover rounded-lg" />
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-2 mt-3">
                                        <UserAvatar
                                            v-if="userStore.last.avatar"
                                            :image="userStore.last.avatar"
                                            :meta-id="userStore.last.metaid"
                                            :name="userStore.last.name"
                                           
                                        />
                                        <span class="font-medium">{{ userStore.last.name || userStore.last.metaid?.slice(0, 6) }}</span>
                                        <span class="text-sm text-base-content/60">{{ formatDate(note.timestamp) }}</span>
                                    </div>
                                </div>
                            </div>

                            <!-- ÂàÜÈ°µÂô® -->
                            <div v-if="totalPages > 1" class="flex justify-center gap-2 mt-8">
                                <button
                                    class="btn btn-sm"
                                    :disabled="currentPage === 1"
                                    @click="handlePageChange(currentPage - 1)"
                                >
                                    ‰∏ä‰∏ÄÈ°µ
                                </button>

                                <div class="join">
                                    <button
                                        v-for="page in getPageNumbers()"
                                        :key="page"
                                        :class="['join-item btn btn-sm', { 'btn-active': page === currentPage, 'btn-disabled': page === -1 }]"
                                        :disabled="page === -1"
                                        @click="page !== -1 && handlePageChange(page)"
                                    >
                                        {{ page === -1 ? '...' : page }}
                                    </button>
                                </div>

                                <button
                                    class="btn btn-sm"
                                    :disabled="currentPage === totalPages"
                                    @click="handlePageChange(currentPage + 1)"
                                >
                                    ‰∏ã‰∏ÄÈ°µ
                                </button>
                            </div>
                        </div>

                        <!-- Á©∫Áä∂ÊÄÅ -->
                        <div v-else class="text-center py-20">
                            <svg class="w-24 h-24 mx-auto text-base-300 mb-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                            </svg>
                            <p class="text-xl text-base-content/60 mb-4">ÊÇ®ËøòÊ≤°ÊúâÂàõÂª∫‰ªª‰ΩïÁ¨îËÆ∞</p>
                            <button @click="goToCreate" class="btn btn-primary">ÂºÄÂßãÂÜô‰Ωú</button>
                        </div>
                    </main>
                </div>
            `,
            setup() {
                const userStore = useUserStore();
                const notes = ref([]);
                const loading = ref(false);
                const total = ref(0);
                const currentPage = ref(1);
                const pageSize = 20;
                const { showToast } = useToast();

                const isAuthorized = computed(() => userStore.isAuthorized);

                const totalPages = computed(() => {
                    if (total.value === 0 || notes.value.length === 0) return 0;
                    return Math.ceil(total.value / pageSize);
                });

                // Ëé∑ÂèñÁ¨îËÆ∞Ê†áÈ¢ò
                const getNoteTitle = (note) => {
                    try {
                        if (note.contentSummary) {
                            const data = JSON.parse(note.contentSummary);
                            return data.title || 'Êó†Ê†áÈ¢ò';
                        }
                        return 'Êó†Ê†áÈ¢ò';
                    } catch (error) {
                        return 'Êó†Ê†áÈ¢ò';
                    }
                };

                // Ëé∑ÂèñÁ¨îËÆ∞Â∞ÅÈù¢
                const getNoteCover = (note) => {
                    try {
                        if (note.contentSummary) {
                            const data = JSON.parse(note.contentSummary);
                            if (data.coverImg && data.coverImg.startsWith('metafile://')) {
                                const pinId = data.coverImg.replace('metafile://', '');
                                return `https://man.metaid.io/content/${pinId}`;
                            }
                            return data.coverImg || '';
                        }
                        return '';
                    } catch (error) {
                        return '';
                    }
                };

                // Âà§Êñ≠Á¨îËÆ∞ÊòØÂê¶Âä†ÂØÜ
                const getNoteIsEncrypt = (note) => {
                    try {
                        if (note.contentSummary) {
                            const data = JSON.parse(note.contentSummary);
                            return data.encryption && data.encryption !== "0";
                        }
                        return false;
                    } catch (error) {
                        return false;
                    }
                };

                // Ê†ºÂºèÂåñÊó•Êúü
                const formatDate = (timestamp) => {
                    const date = new Date(timestamp * 1000);
                    return date.toLocaleDateString('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                };

                // Âä†ËΩΩÁ¨îËÆ∞ÂàóË°®
                const loadNotes = async (page = 1) => {
                    if (!userStore.isAuthorized) {
                        showToast('ËØ∑ÂÖàÁôªÂΩï', 'error');
                        return;
                    }

                    loading.value = true;
                    try {
                        const cursor = (page - 1) * pageSize;
                        const response = await manV2Api.get(`/address/pin/list/${userStore.last.address}`, {
                           
                            path: '/protocols/simplenote',
                            size: pageSize,
                            cursor: cursor
                        });

                        if (response && response.list) {
                            notes.value = response.list;
                            total.value = response.total || 0;
                            currentPage.value = page;
                        } else {
                            notes.value = [];
                            total.value = 0;
                        }
                    } catch (error) {
                        showToast('Âä†ËΩΩÁ¨îËÆ∞Â§±Ë¥•', 'error');
                        console.error('Failed to load notes:', error);
                    } finally {
                        loading.value = false;
                    }
                };

                // ÂàáÊç¢È°µÁ†Å
                const handlePageChange = (page) => {
                    if (page < 1 || page > totalPages.value || page === currentPage.value) {
                        return;
                    }
                    loadNotes(page);
                };

                // Ëé∑ÂèñË¶ÅÊòæÁ§∫ÁöÑÈ°µÁ†ÅÊï∞ÁªÑ
                const getPageNumbers = () => {
                    const total = totalPages.value;
                    const current = currentPage.value;
                    const pages = [];

                    if (total <= 7) {
                        for (let i = 1; i <= total; i++) {
                            pages.push(i);
                        }
                    } else {
                        pages.push(1);

                        if (current <= 3) {
                            pages.push(2, 3, 4, 5);
                            pages.push(-1);
                            pages.push(total);
                        } else if (current >= total - 2) {
                            pages.push(-1);
                            pages.push(total - 4, total - 3, total - 2, total - 1, total);
                        } else {
                            pages.push(-1);
                            pages.push(current - 1, current, current + 1);
                            pages.push(-1);
                            pages.push(total);
                        }
                    }

                    return pages;
                };

                // Êü•ÁúãÁ¨îËÆ∞
                const viewNote = (noteId) => {
                    router.push(`/note/${noteId}`);
                };

                // ËøîÂõûÈ¶ñÈ°µ
                const goBack = () => {
                    router.push('/');
                };

                // Êñ∞Âª∫Á¨îËÆ∞
                const goToCreate = () => {
                    router.push('/note/new');
                };

                watch(isAuthorized, (newVal) => {
                    if (newVal) {
                        loadNotes();
                    }
                });

                onMounted(() => {
                    if (isAuthorized.value) {
                        loadNotes();
                    }
                });

                return {
                    userStore,
                    notes,
                    loading,
                    currentPage,
                    totalPages,
                    isAuthorized,
                    getNoteTitle,
                    getNoteCover,
                    getNoteIsEncrypt,
                    formatDate,
                    handlePageChange,
                    getPageNumbers,
                    viewNote,
                    goBack,
                    goToCreate
                };
            }
        };

        // ‰∏ªÂ∫îÁî®ÁªÑ‰ª∂
        const App = {
            components: {
                ConnectWalletModal,
                LoginUserOperate,
                ToastContainer,
                ProfileEditModal,
                NoteList,
                NoteEditor,
                NoteDetail,
                Draft,
                MyNote
            },
            template: `
                <div class="min-h-screen bg-base-200">
                    <!-- Toast Container -->
                    <ToastContainer />

                    <!-- È°∂ÈÉ®ÂØºËà™Ê†è - Âè™Âú®ÈùûÁ¨îËÆ∞ÂàóË°®È°µÊòæÁ§∫ -->
                    <div v-if="!isNoteListRoute" class="navbar bg-base-100 shadow-lg">
                        <div class="flex-1">
                          
                        </div>
                        <div class="flex-none">
                            <LoginUserOperate />
                        </div>
                    </div>

                    <!-- Ë∑ØÁî±ËßÜÂõæ -->
                    <component :is="currentView" />

                    <!-- ËøûÊé•Èí±ÂåÖÊ®°ÊÄÅÊ°Ü -->
                    <ConnectWalletModal />

                    <!-- Áî®Êà∑ËµÑÊñôÁºñËæëÊ®°ÊÄÅÊ°Ü -->
                    <ProfileEditModal v-model="layoutStore.isShowProfileEditModal" />
                </div>
            `,
            setup() {
                const rootStore = useRootStore();
                const layoutStore = useLayoutStore();
                const connectionStore = useConnectionStore();
                const userStore = useUserStore();
                const credentialsStore = useCredentialsStore();
                const chainStore = useChainStore();
                const { showToast } = useToast();
                const { closeConnectionModal } = useConnectionModal();

                const accountInterval = ref(null);

                // ÂàùÂßãÂåñË∑ØÁî±Á≥ªÁªü
                router = createHashRouter();

                // ËÆ°ÁÆóÂΩìÂâçË∑ØÁî±ËßÜÂõæ
                const currentView = computed(() => {
                    const path = router.currentRoute.value.path;
                    console.log('Current route path:', path);

                    // Ê†πÊçÆË∑ØÂæÑËøîÂõûÂØπÂ∫îÁªÑ‰ª∂
                    if (path === '/' || path === '') {
                        return NoteList;
                    } else if (path === '/draft') {
                        return Draft;
                    } else if (path === '/mynote') {
                        return MyNote;
                    } else if (path === '/note/new') {
                        return NoteEditor;
                    } else if (path.match(/^\/note\/[^/]+\/edit$/)) {
                        return NoteEditor;
                    } else if (path.match(/^\/note\/[^/]+$/)) {
                        return NoteDetail;
                    }

                    // ÈªòËÆ§ËøîÂõûÁ¨îËÆ∞ÂàóË°®
                    return NoteList;
                });

                // Âà§Êñ≠ÊòØÂê¶ÊòØÁ¨îËÆ∞ÂàóË°®Ë∑ØÁî±
                const isNoteListRoute = computed(() => {
                    const path = router.currentRoute.value.path;
                    return path === '/' || path === '';
                });

                // ËøîÂõûÈ¶ñÈ°µ
                const goHome = () => {
                    router.push('/');
                };

                // ËøûÊé•MetaletÈí±ÂåÖ
                async function connectMetalet() {
                    try {
                        const connection = await connectionStore.connect('metalet');
                        if (connection?.status === 'connected') {
                            await credentialsStore.login();
                        }
                    } catch (error) {
                        showToast(error.message, 'error');
                    }
                }

                // Â§ÑÁêÜÁΩëÁªúÂèòÊõ¥
                function handleNetworkChanged(network) {
                    const networkStore = useNetworkStore();
                    const appNetwork = networkStore.network;
                    if (network !== appNetwork) {
                        connectionStore.disconnect();
                    }
                }

                // MetaletË¥¶Êà∑ÂèòÊõ¥Â§ÑÁêÜ
                const metaletAccountsChangedHandler = () => {
                    try {
                        if (connectionStore.last.wallet !== 'metalet') return;
                        if (rootStore.isWebView) return;
                        connectionStore.disconnect();
                        showToast('Metalet Ë¥¶Êà∑Â∑≤ÂèòÊõ¥„ÄÇÊ≠£Âú®Âà∑Êñ∞È°µÈù¢...', 'warning');
                        sleep().then(() => completeReload());
                    } catch (error) {
                        console.error('Error in metaletAccountsChangedHandler:', error);
                    }
                };

                // MetaletÁΩëÁªúÂèòÊõ¥Â§ÑÁêÜ
                const metaletNetworkChangedHandler = (network) => {
                    if (connectionStore.last.wallet !== 'metalet') return;
                    if (rootStore.isWebView) return;
                    handleNetworkChanged(network);
                };

                // AppÁôªÂΩïÊàêÂäüÂ§ÑÁêÜ
                const appLoginSuccessHandler = async (data) => {
                    try {
                        if (!userStore.isAuthorized) {
                            await connectMetalet();
                        }
                    } catch (error) {
                        showToast(error, 'error');
                    }
                };

                // AppË¥¶Êà∑ÂàáÊç¢Â§ÑÁêÜ
                const appAccountSwitchHandler = async (data) => {
                    try {
                        if (rootStore.isWebView) {
                            await connectionStore.disconnect();
                            await connectMetalet();
                        }
                    } catch (error) {
                        throw new Error(error);
                    }
                };

                // AppÁôªÂá∫Â§ÑÁêÜ
                const appLogoutHandler = async (data) => {
                    try {
                        console.log("ÈÄÄÂá∫ÁôªÂΩïÊàêÂäü", data);
                        if (userStore.isAuthorized) {
                            await connectionStore.disconnect();
                            closeConnectionModal();
                        }
                    } catch (error) {
                        console.error('Error in Logout handler:', error);
                    }
                };

                onMounted(async () => {
                    // Á≠âÂæÖ MetaIDJs Âä†ËΩΩÂÆåÊàê
                    await waitForMetaIDJs();
                    console.log('MetaIDJs loaded:', MetaIDJs);
                    console.log('TxComposer:', TxComposer);
                    console.log('mvc:', mvc);

                    // ÂàùÂßãÂåñË¥πÁéá
                    await chainStore.updateAllFeeRates();

                    // ÂÆöÊó∂Ê£ÄÊü•Ë¥¶Êà∑Áä∂ÊÄÅ
                    accountInterval.value = setInterval(async () => {
                        try {
                            rootStore.checkWebViewBridge();
                            if (rootStore.isWebView) return;

                            if (!userStore.isAuthorized) {
                                if (rootStore.isWebView) {
                                    await connectMetalet();
                                }
                            }

                            if (window.metaidwallet && connectionStore.last.status === 'connected' && userStore.isAuthorized) {
                                const res = await window.metaidwallet.getAddress();
                                if (res?.status === 'not-connected' || userStore.last?.address !== res) {
                                    connectionStore.disconnect();
                                    showToast('Metalet Ë¥¶Êà∑Â∑≤ÂèòÊõ¥', 'warning');
                                }
                            }
                        } catch (error) {
                            console.error('Error checking account status:', error);
                        }
                    }, 2000);

                    // ËÆæÁΩÆMetalet‰∫ã‰ª∂ÁõëÂê¨
                    const checkMetalet = () => {
                        rootStore.checkWebViewBridge();
                        if (window.metaidwallet) {
                            try {
                                window.metaidwallet?.on?.('accountsChanged', metaletAccountsChangedHandler);
                                window.metaidwallet?.on?.('networkChanged', metaletNetworkChangedHandler);
                                window.metaidwallet?.on?.('LoginSuccess', appLoginSuccessHandler);
                                window.metaidwallet?.on?.('onAccountSwitch', appAccountSwitchHandler);
                                window.metaidwallet?.on?.('Logout', appLogoutHandler);
                            } catch (err) {
                                console.error('Failed to setup Metalet listeners:', err);
                            }
                        } else {
                            setTimeout(checkMetalet, 100);
                        }
                    };

                    checkMetalet();

                    // Ê£ÄÊü•BTCÂíåMVCÂú∞ÂùÄ‰∏ÄËá¥ÊÄß
                    if (window.metaidwallet && connectionStore.last.status === 'connected' && userStore.isAuthorized) {
                        rootStore.checkBtcAddressSameAsMvc()
                            .catch(() => {
                                showToast('Metalet BTCÂΩìÂâçÂú∞ÂùÄ‰∏éMVCÂú∞ÂùÄ‰∏ç‰∏ÄËá¥ÔºåËØ∑ÂàáÊç¢BTCÂú∞ÂùÄ‰∏éMVCÂú∞ÂùÄ‰∏ÄËá¥ÂêéÂÜçËøõË°å‰ΩøÁî®', 'warning');
                                setTimeout(() => {
                                    connectionStore.disconnect();
                                }, 3000);
                            });
                    }
                });

                onUnmounted(() => {
                    if (accountInterval.value) {
                        clearInterval(accountInterval.value);
                    }

                    // ÁßªÈô§‰∫ã‰ª∂ÁõëÂê¨
                    try {
                        window.metaidwallet?.removeListener?.('accountsChanged', metaletAccountsChangedHandler);
                        window.metaidwallet?.removeListener?.('networkChanged', metaletNetworkChangedHandler);
                        window.metaidwallet?.removeListener?.('LoginSuccess', appLoginSuccessHandler);
                        window.metaidwallet?.removeListener?.('Logout', appLogoutHandler);
                        window.metaidwallet?.removeListener?.('onAccountSwitch', appAccountSwitchHandler);
                    } catch (error) {
                        console.error('Error removing event listeners:', error);
                    }
                });

                return {
                    userStore,
                    connectionStore,
                    layoutStore,
                    currentView,
                    isNoteListRoute,
                    goHome
                };
            }
        };

        // ==================== ÂàùÂßãÂåñÂ∫îÁî® ====================
        const pinia = createPinia();
        const app = createApp(App);
        app.use(pinia);
        app.mount('#app');
    </script>
</body>
</html>
